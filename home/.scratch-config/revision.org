#+title: Streamline literate config
#+startup: show2levels
#+ARCHIVE: ~/Org/archive.org::* From %s

* Commentary
:PROPERTIES:
:visibility: folded
:END:
** On early initialization
My previous approach auto-tangled this out of the same file as everything else. It's not something that I revist often or have all that much commentary on. I think it's OK to have that outside of the tangled file, because I /think/ that the approach then becomes tangling the config on startup.
** Startup speed and servers
I definitely like keeping a server running. I think I'd like to make it easier to leave the server running without a frame, but maybe there's really not that much need.
I think terminal for things like git commit message? I wonder if you could make it open the magit changes view alongside it in terminal
** Why I'm rewriting this
I've been using my scratch config full-time for a while, and I think I'm ready for a refactor now that I better understand what I do and don't need, and how it will all fit together
** Organization
I've found that I strongly dislike the huge blocks I end up writing for some of the more  complex packages. It puts too many things in one place to really do the literate thing. But I refuse to have individual blocks that aren't a complete sexp.
There are a couple options to deal with this. There's a sort of constant substitution thing, which requires listing out all the sections that will be inserted. What I want is to be able to use something like Rails' ~content-for~ directives. The sections I want correspond to the keywords of the ~use-package~ 
This could probably be done with a macro but that frightens me.
* Notes on key commands
:PROPERTIES:
:visibility: all
:END:
Not any particularly significance or sort order, just things I'm trying to learn:
| Prefix | Key           | Command                               |
|--------+---------------+---------------------------------------|
|        | =C-x n=       | prefix for narrowing commands         |
|        | =C-x n s=     | narrow to subtree                     |
|        | =C-x n p=     | narrow to page                        |
| =C-u=  | =C-x ==       | what-cursor-position                  |
|--------+---------------+---------------------------------------|
|        | =C-c C-v d=   | insert babel source block[fn:1]       |
|        | =C-c C-x b=   | indirect buffer of current subtree    |
|        | =C-c C-x C-a= | archive current subtree               |
| =C-u=  | =C-c C-x C-a= | ask about archiving children          |
|--------+---------------+---------------------------------------|
|        | =M-m=         | back-to-indentation                   |
|        | =M-n=         | (at prompt) next history item (guess) |
|--------+---------------+---------------------------------------|
|        | =M-s h .=     | highlight symbol at point             |

* Bootstrap straight and use-package
This is now done directly in =init.el= so that we pick up the straight-managed version of org instead of the built in one. There's still probably some issues with getting configuration to all happen at the right time, though...
* Built-in options for basic emacs configuration
Introduce myself to Emacs:
#+begin_src elisp
(setq user-full-name "Emily Hyland"
      user-mail-address "hello@duien.com")
#+end_src

Set up some very basic (and mostly self-explanatory) options:
#+begin_src elisp
(setq inhibit-startup-screen t
      sentence-end-double-space nil
      vc-follow-symlinks t
      dired-use-ls-dired nil
      fill-column 80
      tool-bar-mode -1
      toggle-scroll-bar -1
      mouse-wheel-tilt-scroll t
      custom-safe-themes t
      )
#+end_src

Putting these here instead of in =early-init= means we get a brief glimpse of the default window position, then resize, but it also means that they respect our actual font size.
#+begin_src elisp
(push '(width . 100) default-frame-alist)
(push '(height . 0.8) default-frame-alist)
(push '(min-height . 40) default-frame-alist)
(push '(top . 0.25) default-frame-alist)
(push '(left . 0.5) default-frame-alist)
#+end_src

Always allow `y' instead of `yes' in all prompts
#+begin_src elisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

If you type over a selection, delete it first
#+begin_src elisp
(delete-selection-mode t)
#+end_src
** Everything should always be UTF-8
#+begin_src elisp
(set-charset-priority 'unicode)
(setq locale-coding-system 'utf-8
      coding-system-for-read 'utf-8
      coding-system-for-write 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src
** Set up basic minor modes
#+begin_src elisp
(delete-selection-mode t)
(recentf-mode t)
(setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                        ,(expand-file-name "eln-cache/" user-emacs-directory)
                        ,(expand-file-name "etc/" user-emacs-directory)
                        ,(expand-file-name "var/" user-emacs-directory)))
(winner-mode t) ;; undo/redo window layout changes
(show-paren-mode t)
(display-time-mode -1)
#+end_src
** Set up reasonable indentation defaults
Attempt to make indentation do sensible things:
#+begin_src elisp
(setq-default indent-tabs-mode nil) ;; never use tabs to indent
(setq-default tab-width 2)
(setq js-indent-level 2)
(setq tab-always-indent t
      require-final-newline t)
#+end_src

And let other people decide per-project values:
#+begin_src elisp
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src
** Prevent autosave and backup files littered everywhere
#+begin_src elisp
(setq backup-directory-alist
      '((".*" . "~/.emacs-backups")))
(setq auto-save-file-name-transforms
      '((".*" "~/.emacs-backups" t)))
(setq
 auto-save-default t
 version-control t     ; number each backup file
 backup-by-copying t   ; instead of renaming current file (clobbers links)
 delete-old-versions t ; clean up after itself
 kept-old-versions 5
 kept-new-versions 5
 auto-save-include-big-deletions t)
#+end_src
** Configure things for mac
Set up what seems to be the least annoying modifier key setup:
#+begin_src elisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
  (setq mac-control-modifier 'control))
#+end_src
** Technical bits
Some inside baseball options I don't really understand:
#+begin_src elisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
;; less noise when compiling elisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
(setq native-comp-async-report-warnings-errors nil)
(setq load-prefer-newer t)

  (setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
  (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
  (setq enable-local-variables :all)     ; fix =defvar= warnings

#+end_src
** Keybindings
*** The surprisingly complicated question of =ESC=
I don't want ESC as a modifier. When I was coming from vim/evil it was just too confusing and tripped me up all the time.
Advice would say use ~keyboard-escape-quit~ as the binding here, which is what's originally bound to =ESC-ESC-ESC= but that makes it too easy to end up closing additional windows, which is basically never what I want.It turns out, however, that ~keyboard-quit~ is not what I want either since it doesn't get me out of the minibuffer. UGH.
What I've ended up with is using ~keyboard-escape-quit~ but modifying it so that the function it calls to kill a buffer just beeps instead. I'm not sure if it actually beeps, though. Am I good at ignoring it, have I retrained myself better than expected, or does it just not work?
#+begin_src elisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq-default buffer-quit-function
	            #'(lambda () (beep)))
#+end_src
**** IDEA What if ~buffer-quit-function~ closed non-file-visiting buffers but left open any file-visiting? That might let it get out of help windows but not out of actual buffer layout.
*** Use general to set up keybindings in a friendlier way
#+begin_src elisp
(use-package general
  :demand t)
(general-define-key "<help> F" 'describe-face)
(general-define-key "C-x z" 'bury-buffer)
#+end_src
* How it looks
** Set up typography
Typography in Emacs can be very fiddly. Some links that might help sometimes?
[[https://stackoverflow.com/questions/67555133/emacs-not-listing-semilight-fonts][Emacs and fontconfig disagree about font weights]]

*** With the Recursive font
Set up fixed and variable pitch fonts with very similar character. It's a dynamic font, but unfortunately Emacs doesn't actually know how to handle that. So for now, we use two separate sets of static configs.
#+begin_src elisp
(defun eh/set-recursive-fonts ()
  (set-face-attribute 'default nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Recursive Sans Casual Static"
                      :height 160 :weight 'normal)
  )
#+end_src

*** With Pragmata Pro
#+begin_src elisp
(defun eh/set-pragmata-fonts ()
  (set-face-attribute 'default nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  )
#+end_src

**** All the extra ligatures and things
For PragmataPro, there are so many additional ligatures and things that are beyond what's needed for other fonts. The normal ligature configuration will not be sufficient, so we'd need to add a couple things to really get it working

[[https://github.com/lumiknit/emacs-pragmatapro-ligatures][emacs-pragmatapro-ligatures]] package on Github should set everything up for the most recent version.

However, MyFonts is stupid, and so I'm missing one style (PragmataPro Liga Regular) in the lastest version. I can use the mono version, but it's missing some of the more complex things. It _might_ be possible to set up a fallback font?

[[https://stackoverflow.com/questions/6083496/how-do-you-specify-a-fallback-font-in-emacs][This StackOverflow post]] has some information about how to do that, but not sure if it will really work for this weird situation.

*** With Plex fonts
#+begin_src elisp
(defun eh/set-plex-fonts ()
  (set-face-attribute 'default nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "iA Writer Quattro V"
                      :height 160 :weight 'semilight)
  )
#+end_src

*** With Input fonts
#+begin_src elisp
(defun eh/set-input-fonts ()
  (set-face-attribute 'default nil
                      :family "Input Mono Condensed"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :family "Input Mono Condensed"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :family "Input Sans Condensed"
                      :height 160 :weight 'normal)
  )
#+end_src
*** With Sudo fonts
#+begin_src elisp
(defun eh/set-sudo-fonts ()
  (set-face-attribute 'default nil
		      :font "Sudo"
		      :height 200 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
		      :font "Sudo"
		      :height 200 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
		      :font "Sudo UI"
		      :height 200 :weight 'normal))
#+end_src

*** Combinations with Victor

Victor and Galix are a fun combo.
#+begin_src elisp
(defun eh/set-victor-galix-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Galix"
                      :height 170 :weight 'normal)
  )
#+end_src

#+begin_src elisp
(defun eh/set-victor-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 170 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 170 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Overpass"
                      :height 170 :weight 'semilight)
  )
#+end_src

*** Belinsky
#+begin_src elisp
(defun eh/set-belinsky-fonts ()
  (set-face-attribute 'default nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  )
#+end_src
*** MonoLisa
MonoLisa is such a good font. The script version (installed as "MonoLisa Script") is also very good, but can be a little overwhelming for longer blocks of text. It might be interesting to try using both the italic and the script for different faces.
#+begin_src elisp
(defun eh/set-monolisa-fonts ()
  (set-face-attribute 'default nil
                      :family "MonoLisa Custom"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "MonoLisa Custom"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "MonoLisa Custom"
                      :height 160 :weight 'light)
  )
#+end_src
*** Cascadia
#+begin_src elisp
(defun eh/set-cascadia-fonts ()
  (set-face-attribute 'default nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  ;; hack
  (set-face-attribute 'font-lock-function-name-face nil
                      :weight 'medium)
  )
#+end_src
*** With Operator fonts
#+begin_src elisp
(defun eh/set-operator-fonts ()
  (set-face-attribute 'default nil
                      :font "Operator Mono SSm"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Operator Mono SSm"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Operator Mono SSm"
                      :height 160 :weight 'light)
  )
#+end_src
*** With Codelia
#+begin_src elisp
(defun eh/set-codelia-fonts ()
  (set-face-attribute 'default nil
                    :font "Codelia Ligatures"
                    :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                    :font "Codelia Ligatures"
                    :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                    :font "Codelia Ligatures"
                    :height 160 :weight 'normal))
#+end_src


*** With Apple fonts
#+begin_src elisp
(defun eh/set-simple-apple-fonts ()
  (set-face-attribute 'default nil
                      :font "SF Mono"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'fixed-pitch nil
                      :font "SF Mono"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'variable-pitch nil
                      :font "SF Pro Text"
                      :height 160 :weight 'semilight)
  )
(defun eh/set-fancy-apple-fonts ()
  (set-face-attribute 'org-document-title nil
                      :font "New York Extra Large"
                      :height 2.0 :weight 'bold)
 
  (set-face-attribute 'org-level-1 nil
                      :family "New York Medium"
                      :weight 'semibold :height 1.4)
  ;; Causing issues with line-height on TODO items
  ;; (set-face-attribute 'org-level-2 nil
  ;;                     :family "New York Medium"
  ;;                     :weight 'semibold
  ;;                     :height 1.2)
  (set-face-attribute 'org-ellipsis nil
                    :font "SF Mono"
                    :inherit '(shadow default))
  )
(defun eh/set-apple-fonts ()
  (eh/set-simple-apple-fonts)
  (eh/set-fancy-apple-fonts)
  )
#+end_src

*** And finally, enable a font!
#+begin_src elisp
;; (eh/set-recursive-fonts)
;; (eh/set-pragmata-fonts)
;; (eh/set-plex-fonts)
;; (eh/set-victor-fonts)
;; (eh/set-input-fonts)
;; (eh/set-sudo-fonts)
;; (eh/set-apple-fonts)
;; (eh/set-monolisa-fonts)
;; (add-hook 'after-enable-theme-hook #'eh/set-apple-fonts)
(add-hook 'after-enable-theme-hook #'eh/set-monolisa-fonts)
#+end_src

Interestingly, it turns out that ~mixed-pitch-mode~ doesn't deal well with changing fonts after the fact (even after toggling the mode)

But ~variable-pitch-mode~ seems to do just fine with it. I think I switched because of ... some very specific issues. Let's go back to variable for a while?

I've left mixed installed, but [[*Basic configuration][the org-mode hook configuration]] is what controls what we actually use. It's also set in [[*Writing in Markdown][markdown/gfm mode configuration]] as well.
*** Set up ligatures in various ways
Turn on automatic ligatures if the feature is available:
#+begin_src elisp
(when (fboundp 'mac-auto-operator-composition-mode)
  (setq mac-auto-operator-composition-characters "!\"#$%&'()+,-./:;<=>?@[\\]^_`{|}~w")
  (mac-auto-operator-composition-mode))
#+end_src

Or turn it on the hard way:
#+begin_src elisp
(use-package ligature
  :straight
  '(ligature :type git :host github
             :repo "mickeynp/ligature.el")
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"
                                       "[FAIL]" "[BUG]" "[DEBUG]" "[ERR]" "[ERROR]" "[FAIL]" "[FATAL]"
                                       "[FIXME]" "[HACK]" "[INFO]" "[INFO ]" "[KO]" "[MARK]" "[NOTE]"
                                       "[OK]" "[PASS]" "[PASS ]" "[TODO]" "[TRACE]" "[VERBOSE]"
                                       "[WARN]" "[WARN ]" "[WARNING]"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  ;; (global-ligature-mode t)
  )
#+end_src
** Color Theming
*** Set up a hook that's  run after loading a theme
Any theme customization that's done with ~set-face-attribute~ gets lost whenever we switch themes.  Usually you'd solve that with customize, but I kind of hate it. So, instead, we create our own hook taht's run on theme change to set those sorts of things.
#+begin_src elisp
(defvar after-enable-theme-hook nil
   "Normal hook run after enabling a theme.")

(defun run-after-enable-theme-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'after-enable-theme-hook))

(advice-add 'enable-theme :after #'run-after-enable-theme-hook)
#+end_src
*** Set up Modus
First, define a few functions that are useful to our use of Modus:
#+begin_src elisp
(defun eh/modus-customize ()
  (set-face-attribute 'font-lock-string-face nil :slant 'italic)
  ;; (set-face-attribute 'org-document-title nil :height 1.5)
  )

(defun eh/load-theme (appearance)
  "Load theme, taking current system APPEARANCE into consideration."
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (modus-themes-load-operandi))
    ('dark (modus-themes-load-vivendi))))

(defun eh/org-update-modus-theme ()
  (set-face-attribute 'org-headline-todo nil
                      :foreground nil)
  (set-face-attribute 'eh/org-keyword-todo nil
                      :inherit '(modus-themes-refine-green org-todo))
  (set-face-attribute 'eh/org-keyword-next nil
                      :inherit '(modus-themes-refine-yellow org-todo))
  (set-face-attribute 'eh/org-keyword-halt nil
                      :inherit '(modus-themes-intense-red org-todo))
  (set-face-attribute 'eh/org-keyword-bury nil
                      :inherit '(modus-themes-intense-neutral org-done))
  (set-face-attribute 'eh/org-keyword-question nil
                      :inherit '(modus-themes-refine-blue org-todo))
  (set-face-attribute 'eh/org-keyword-idea nil
                      :inherit '(modus-themes-refine-cyan org-todo))
  (set-face-attribute 'eh/org-keyword-yaks nil
                      :inherit '(modus-themes-refine-magenta org-todo))
  (set-face-attribute 'eh/org-keyword-done nil
                      :inherit '(modus-themes-nuanced-green org-done)
                      :foreground (modus-themes-color 'green-faint))
  (set-face-attribute 'eh/org-keyword-kill nil
                      :inherit '(modus-themes-nuanced-red org-done)
                      :foreground (modus-themes-color 'red-faint))
  (set-face-attribute 'eh/org-keyword-answer nil
                      :inherit '(modus-themes-nuanced-blue org-done)
                      :foreground (modus-themes-color 'blue-faint))
  (set-face-attribute 'eh/org-keyword-meh nil
                      :inherit 'eh/org-keyword-answer
                      :foreground (modus-themes-color 'blue))
  (set-face-attribute 'eh/org-keyword-yes nil
                      :inherit 'eh/org-keyword-done
                      :foreground (modus-themes-color 'green))
  (set-face-attribute 'eh/org-keyword-no nil
                      :inherit 'eh/org-keyword-kill
                      :foreground (modus-themes-color 'red))
  )
#+end_src

#+begin_src elisp
(use-package modus-themes
  :config
  (setq modus-themes-mixed-fonts t
        modus-themes-variable-pitch-ui nil ;; bad w/ nano
        modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-subtle-line-numbers t
        modus-themes-markup '(background intense)
        modus-themes-links '(background)
        modus-themes-fringes nil ;; background of fringe area
        modus-themes-mode-line '(accented)
        modus-themes-syntax '(green-strings)
        modus-themes-org-blocks 'gray-background
        modus-themes-completions '((t background intense accented))
        modus-themes-region '(bg-only accented)
        )
  ;; (add-hook 'ns-system-appearance-change-functions #'eh/load-theme)
  :init
  (modus-themes-load-themes)
  :hook
  ;; (modus-themes-after-load-theme . eh/set-apple-fonts)
  (modus-themes-after-load-theme . eh/modus-customize)
  (modus-themes-after-load-theme . eh/org-update-modus-theme)
  )
#+end_src
*** Set up some alternate color themes
#+begin_src elisp
(use-package iodine-theme)
(use-package poet-theme
  :config
  (setq poet-theme-variable-headers nil
        poet-theme-variable-pitch-multiplier 1))
(use-package spacemacs-theme
  :custom
  (spacemacs-theme-comment-bg nil)
  (spacemacs-theme-comment-italic t)
  (spacemacs-theme-org-height nil))
(use-package solo-jazz-theme)
(use-package flucui-themes)
(use-package doom-themes
  :config
  (setq doom-isohedron-brighter-modeline t)
  (setq doom-earl-grey-brighter-modeline t)
  )
(use-package nano-theme)
(use-package bespoke-theme
  :straight (:host github :repo "mclear-tools/bespoke-themes" :branch "main"))

;; (load-theme 'modus-operandi)

;; (with-eval-after-load 'org
;; (modus-themes-load-operandi))
#+end_src
*** View named colors
#+begin_src elisp
(use-package rainbow-mode)
#+end_src
*** Fancy and unnecessary SVG tags
#+begin_src elisp
(use-package svg-lib)
(use-package svg-tag-mode
  :straight (:type git :host github :repo "rougier/svg-tag-mode")
  :config
  (setq svg-tag-tags
      '((":TODO:" . ((lambda (tag) (svg-tag-make "TODO")))))))
#+end_src
** Interface
*** IDEA Make the mark always visible
This is a start. It adds the ability to visualize the mark, but (at least with transient-mark-mode) it only seems to show them when the mark is active.
#+begin_src elisp
(use-package visible-mark
  :config
  (setq visible-mark-max 5)
  :init
  ;; (global-visible-mark-mode 1)
  )
#+end_src
*** Use mixed pitch fonts
#+begin_src elisp
(use-package mixed-pitch
  :ensure t)
#+end_src
This is really determined by which mode we load in org. I'd been using variable-pitch-mode but it's doing something weird with tables (every character I check says it's mono, but the lines don't line up). I think overall mixed-pitch-mode works better, but had some compatibility issues, possibly involving dimmer and/or changing fonts.
**** TODO 
*** Show horizontal rules instead of =^L= 
#+begin_src elisp
(use-package form-feed
  :init
  (form-feed-mode t))
#+end_src
-
*** A better mode-line
#+begin_src elisp
(use-package nano-modeline
  :config
  (setq nano-modeline-position 'bottom
        nano-modeline-space-top 0.15 ;; 0.15
        nano-modeline-space-bottom -0.2 ;; -0.2
        )
  :hook (after-init . nano-modeline-mode))
(use-package bespoke-modeline
  :straight (bespoke-modeline :type git :host github :repo "mclear-tools/bespoke-modeline")
  :config
  (setq bespoke-modeline-position 'top
        bespoke-modeline-vc-symbol "#"))
#+end_src

Additional bespoke modeline options:
#+begin_example
bespoke-modeline-(gui|tty)-(mod|rw|ro)-symbol
bespoke-modeline-space-(bottom|top)
? bespoke-modeline-user-mode
bespoke-modeline-vc-symbol
bespoke-modeline-visual-bell
face for bespoke-modeline-visual-bell-config
#+end_example

Use minions to hide all the minor mode indicators in a menu
#+begin_src elisp
(use-package minions
  :config
  (setq minions-mode-line-lighter "≡")
  :init (minions-mode 1))
#+end_src
*** A dashboard
#+begin_src elisp
(use-package dashboard
  :ensure t
  :config
  (setq dashboard-projects-backend 'projectile
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-set-init-info t
        )
  (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (projects . 5)
                        (agenda . 5)
                        ))
  ;; (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  :init
  (dashboard-setup-startup-hook))
#+end_src 
*** A menu of keybindings when you pause
#+begin_src elisp
(use-package which-key
  :config
  ;; this is the default
  (which-key-setup-side-window-bottom)
  :init
  (which-key-mode))
#+end_src
*** Make help more helpful
#+begin_src elisp
(use-package helpful
  :general
  ("C-h f" 'helpful-callable)
  ("C-h v" 'helpful-variable)
  ("C-h k" 'helpful-key)
  ("C-h C" 'helpful-command) ;; only interactive functions
  ;; this is overwritten by set-deadline in org
  ("C-c C-d" 'helpful-at-point)
  )
#+end_src
*** Selectively dim windows
It's a choice between solaire, which dims non-file-visiting buffers, and dimmer, which dims inactive buffers. Wouldn't rule-based buffer colors be cool?
**** BURY Solaire
**** Dimmer
#+begin_src elisp
(use-package dimmer
  :config
  (setq dimmer-fraction 0.4) ;; this is right for isohedron
  (dimmer-configure-which-key)
  (dimmer-configure-org)
  (dimmer-configure-magit)
  ;; (dimmer-configure-posframe)
  ;; (dimmer-configure-hydra) ;; ??
  (dimmer-mode 1)
  )
#+end_src
*** Show the minibuffer somewhere more visible
#+begin_src elisp
(use-package mini-frame
  :config
  (setq mini-frame-background-color-function
        (lambda ()
          (face-attribute 'mode-line-inactive :background)))
  (setq mini-frame-show-parameters
        '((child-frame-border-width . 8) ;; give it breathing room
          (no-accept-focus . t) ;; makes initial height work correctly
          (left . 0.5) ;; center horizontally
          (top . 0.25) ;; about a quarter down
          (width . 0.8) ;; narrower than the frame usually
          (min-width . 60) ;; never too narrow
          (height . 1) ;; default to one line
          (min-height . 1) ;; it can be as little as it wants
          (keep-ratio . t) ;; keep proportion as parent resizes
          (left-fringe . 8) ;; extra side padding
          (right-fringe . 8) ;; for both sides
          ))
  (setq mini-frame-resize t)
  :init
  ;; (mini-frame-mode t)
  )
#+end_src
*** Tweak frame display
This uses a background-color column to divide windows instead of drawing a line:
#+begin_src elisp
(use-package frame
  :straight (:type built-in)
  :custom
  (window-divider-default-right-width 12)
  (window-divider-default-bottom-width 1)
  (window-divider-default-places 'right-only)
  (window-divider-mode t)
  :hook
  (before-make-frame . window-divider-mode))
#+end_src
* What it can do
** Vertical completion interface
This is what's used when switching buffers, searching for files, refiling to an org headline, all that stuff.
*** Set up consult first
Consult is what sets the contents of those menus. It provides a really nice buffer switch interface, ~consult-buffer~, which includes a variety of sources and the ability to use a single-letter prefix to filter them exclusively.
#+begin_src elisp
  (use-package consult
    :demand t
    :config
    ;; Don't automatically preview things
    (setq consult-preview-key (kbd "M-."))
    ;; :init
    (setq consult-project-root-function #'projectile-project-root)
    :general
    ("C-x b" 'consult-buffer)
    ("C-x 4 b" 'consult-buffer-other-window)
    ("C-x 5 b" 'consult-buffer-other-frame)
    ;; consult-yank-from-kill-ring
    ;; consult-yank-pop
    ("<help> a" 'consult-apropos)
    ("<help> t" 'consult-theme))
#+end_src

It still only operates on the single line, but it provides the nicer menus, and allows previewing the thing to be switched to (buffers, themes, etc).
*** Set up vertico
Vertico is what takes the completion functions from consult and turns them into what we'd normally think of as an autocomplete window. It's a few lines high, shows the input at the top, and provides a list of the possible results. You can move up and down through the list, or continue typing to keep narrowing.
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode))
#+end_src
*** Use orderless matching
Speaking of matching, it's something that apparently I have Opinions about. It's important for the way I use it (and the organization of the projects I'm often navigating) that I can add additional elements to the match out of order. I might start searching for a model, =mod= then =us= for user. Oh, but I need the spec, so =spec=. In a lot of completion setups, I'd have to go back to the beginning of the string to add a filter that's higher up in the file tree. But with orderless, I can add the tokens in whatever order I want!
In order for that not to make the search space too big, I then have to separate the tokens with spaces. It can sometimes be annoying, but it's sometimes actually useful for disambiguation.
#+begin_src emacs-lisp
(use-package orderless
  :config
  (defun flex-if-twiddle (pattern _index _total)
    (when (string-suffix-p "~" pattern)
      `(orderless-flex . ,(substring pattern 0 -1))))

  (defun without-if-bang (pattern _index _total)
    (cond
     ((equal "!" pattern)
      '(orderless-literal . ""))
     ((string-prefix-p "!" pattern)
      `(orderless-without-literal . ,(substring pattern 1)))))
  :init
  (setq orderless-matching-styles '(orderless-regexp)
        orderless-style-dispatchers '(without-if-bang flex-if-twiddle))
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Show marginalia when completing
This adds the additional columns to the completion window. Extra info, and I think it fixes an alignment issue with variable pitch fonts.
#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode))
#+end_src
** Scratch buffer is magic
I use the scratch buffer a lot, and it's nice to have the things there stick around unless I delete them on purpose. It's a good place to stash log output, temporary shell command editing, things like that, but sometimes I need to restart my editor while still in the middle of those tasks.
#+begin_src elisp
(use-package persistent-scratch
  :demand t
  :config
  (setq persistent-scratch-backup-directory "~/.emacs-backups")
  :init
  (persistent-scratch-setup-default)
  (persistent-scratch-mode 1))
#+end_src
** Version control
Set up the best git interface:
#+begin_src elisp
(use-package magit)
#+end_src

See which lines have been modified in the gutter
#+begin_src elisp
(use-package diff-hl
  :hook
  (magit-pre-refresh . diff-hl-magit-pre-refresh)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :init
  (global-diff-hl-mode 1))
#+end_src
** Use projects for organization
#+begin_src elisp
(use-package projectile
  :config
  (setq projectile-project-search-path
	'(("~/Code" . 3)
	  ("~/.homesick/repos" . 1)))
  (projectile-add-known-project "~/Org")
  (projectile-add-known-project "~/Notes")
  :general
  ("C-x p" '(:keymap projectile-command-map :package projectile))
  ("C-x p b" 'consult-project-buffer)
  :init
  (projectile-mode 1))
#+end_src
** A shell in the editor
#+begin_src elisp
(use-package vterm)
#+end_src
** Organize and focus on buffer groups
This is neat to keep around as a tool when I might want it, but not something I expect to get a lot of use from.
#+begin_src elisp
(use-package bufler
  :init
  (bufler-mode))
#+end_src
* Simple utilities for better editing
** Miscellaneous commands :crux:expand_region:rainbow:logos:olivetti:ws_butler:
Crux has lots of handy utility functions. These are a few of the best:
#+begin_src elisp
(use-package crux
  :general
  ("C-o" 'crux-smart-open-line)
  ("M-o" 'crux-smart-open-line-above)
  ("C-k" 'crux-smart-kill-line)
  )
#+end_src

Expanding the region incrementally is incredibly helpful:
#+begin_src elisp
(use-package expand-region
  :general
  ("C-=" 'er/expand-region))
#+end_src

Allow highlighting color-like things in their colors. This isn't very smart about things, and tends to highlight named colors in an annoying number of places, but when it's useful it's really useful.
#+begin_src elisp
(use-package rainbow-mode)
#+end_src

Move forward and backward through pages when the buffer is narrowed:
#+begin_src elisp
(use-package logos
  :config
  (setq logos-outlines-are-pages t)
  :general
  ([remap narrow-to-region] 'logos-narrow-dwim)
  ([remap forward-page] 'logos-forward-page-dwim)
  ([remap backward-page] 'logos-backward-page-dwim))
  
(use-package olivetti
  :config
  (setq olivetti-style nil))
#+end_src
Getting rid of ~visual-fill-column-mode~ in favor of olivetti. I think overall, having regular ~visual-line-mode~ is a better default, and olivetti is simple (and I can remember the dang name!)

Manage whitespace automatically:
#+begin_src elisp
(use-package ws-butler
  :hook
  (prog-mode . ws-butler-mode))
#+end_src
** Do better things with line wrapping
#+begin_src elisp
(use-package adaptive-wrap)
(setq-default word-wrap t)
(setq-default truncate-lines t)
#+end_src
** Parentheses matching and surround :smartparens:
#+begin_src elisp
(use-package smartparens
  :config
  :init
  (require 'smartparens-config)
  (smartparens-global-mode 1)
  )
#+end_src
** Toggle between vertical and horizontal split windows
#+begin_src elisp
(defun eh/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+end_src
** Pulse the line after movement :pulsar:
#+begin_src elisp
(use-package pulsar
  :config
  (setq pulsar-pulse nil ;; nil to leave the highlight in place until another command
        pulsar-delay 0.5 ;; how long each step lasts
        pulsar-iterations 1 ;; how many steps for color
        pulsar-face 'pulsar-yellow
        )
  :general
  ;; Bind pulsar-hightlight-dwim
  ;; Bind pulsar-pulse-line
  :init
  (pulsar-global-mode 1)
  (add-to-list 'pulsar-pulse-functions 'org-cycle)
  (add-to-list 'pulsar-pulse-functions 'isearch-repeat-forward)
  ;; pulsar-face
  )
#+end_src
** Highlight occurrences of multiple symbols :highlight_symbol:
#+begin_src elisp
(use-package highlight-symbol)
;; highlight-symbol-mode for persistent highlights
;; highlight-symbol-nav-mode for M-n / M-p navigation through occurrences
;; highlight-symbol to highlight symbol at point
#+end_src
* Set up org-mode
** Prepare for org configuration

Define custom faces for all of our keywords. This allows redone styles to be loaded without reload org-mode
#+begin_src elisp
    (cl-defun eh/org-register-keyword (&key keywords face symbol)
      (dolist (key keywords)
        (add-to-list 'org-todo-keyword-faces `(,key . ,face))
        (add-to-list 'org-superstar-todo-bullet-alist `(,key . ,symbol))
      ))
    (defun eh/define-org-keywords ()
      ;; Register all variations of keywords with faces and symbols
      ;; Only the ones included in `org-todo-keywords' will be
      ;; activated by default, but the others will still be styled
      ;; if activated by buffer properties

      ;; First, clear out (and register) the two lists we're building up
      (setq org-todo-keyword-faces '()
            org-superstar-todo-bullet-alist '())

      (eh/org-register-keyword
       :keywords '("DONE")
       :symbol ?✓
       :face (defface eh/org-keyword-done '((t :inherit org-done))
               "Face used for the DONE keyword in Org"))
      (eh/org-register-keyword
       :keywords '("KILL" "CANCEL")
       :symbol ?×
       :face (defface eh/org-keyword-kill '((t :inherit org-done))
               "Face used for the KILL keyword in Org"))
      (eh/org-register-keyword
       :keywords '("ANSWER" "ANSR")
       :symbol ?·
       :face (defface eh/org-keyword-answer '((t :inherit org-done))
               "Face used for the ANSR keywork in Org"))
      (eh/org-register-keyword
       :keywords '("MEH" "OK")
       :symbol ?·
       :face (defface eh/org-keyword-meh '((t :inherit org-done))
               "Face used for the OK keyword in Org"))
      (eh/org-register-keyword
       :keywords '("YES")
       :symbol ?·
       :face (defface eh/org-keyword-yes '((t :inherit eh/org-keyword-done))
               "Face used for the YES keyword in Org"))
      (eh/org-register-keyword
       :keywords '("NO")
       :symbol ?·
       :face (defface eh/org-keyword-no '((t :inherit eh/org-keyword-kill))
               "Face used for the NO keyword in Org"))
      (eh/org-register-keyword
       :keywords '("BURY" "WAIT" "HOLD" "LATER")
       :symbol ?~
       :face (defface eh/org-keyword-bury '((t :inherit org-todo))
               "Face used for the WAIT keyword in Org"))
      (eh/org-register-keyword
       :keywords '("NEXT" "FLAG")
       :symbol ?☐ ;; ?◦
       :face (defface eh/org-keyword-next '((t :inherit org-todo))
               "Face used for the FLAG keyword in Org"))
      (eh/org-register-keyword
       :keywords '("TODO")
       :symbol ?☐ ;; ?◦
       :face (defface eh/org-keyword-todo '((t :inherit org-todo))
               "Face used for the TODO keyword in Org"))
      (eh/org-register-keyword
       :keywords '("HALT" "BLOK" "BLOCK")
       :symbol ?◊
       :face (defface eh/org-keyword-halt '((t :inherit org-todo))
               "Face used for the BLOK keyword in Org"))
      (eh/org-register-keyword
       :keywords '("QUEST" "QSTN" "QUESTION")
       :symbol ??
       :face (defface eh/org-keyword-question '((t :inherit org-todo))
               "Face used for the QSTN keyword in Org"))
      (eh/org-register-keyword
       :keywords '("IDEA")
       :symbol ?ҩ ;; ¤φ
       :face (defface eh/org-keyword-idea '((t :inherit org-todo))
               "Face used for the IDEA keyword in Org"))
      (eh/org-register-keyword
       :keywords '("YAKS" "YAK")
       :symbol ?∞
       :face (defface eh/org-keyword-yaks '((t :inherit org-todo))
               "Face used for the YAK keyword in Org"))
      )
#+end_src

Set up some basic org styling that we'll run whenever we change themes:
#+begin_src elisp
(defun eh/org-update-theme ()
  ;; default styling for task keywords
  (set-face-attribute 'org-todo nil
                      :inherit 'fixed-pitch
		                  :box nil
		                  :height 1.0
                      :weight (face-attribute 'bold :weight))
  (set-face-attribute 'org-done nil
                      :inherit 'fixed-pitch
           	          :slant 'italic
                      :weight (face-attribute 'default :weight))
  (set-face-attribute 'eh/org-keyword-bury nil
                      :weight (face-attribute 'default :weight))

  ;; styling for headlines with keywords
  (set-face-attribute 'org-headline-todo nil
                      ;; :foreground (face-attribute 'default :foreground)
                      :weight (face-attribute 'default :weight))
  (set-face-attribute 'org-headline-done nil
                      :inherit '(font-lock-comment-face default))

  ;; set things up for mixed/variable pitch
  (set-face-attribute 'org-hide nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)

  ;; Now set up theme-specific things?
  (when (eq (car custom-enabled-themes) 'doom-isohedron)
    (message "Setting up org faces for Isohedron")
    (set-face-attribute 'org-todo nil
                        :foreground (doom-color 'bg)
                        :background (doom-color 'fw-base3))
    (set-face-attribute 'eh/org-keyword-todo nil
                        :background (doom-color 'fw-green))
    (set-face-attribute 'eh/org-keyword-question nil
                        :background (doom-color 'fw-blue))
    (set-face-attribute 'eh/org-keyword-idea nil
                        :background (doom-color 'fw-teal))
    (set-face-attribute 'eh/org-keyword-yaks nil
                        :background (doom-color 'fw-purple))
    (set-face-attribute 'eh/org-keyword-next nil
                        :foreground (doom-color 'fw-yellow-text)
                        :background (doom-color 'fw-yellow))
    (set-face-attribute 'eh/org-keyword-bury nil
                        :foreground (doom-color 'fg-alt)
                        :background (doom-color 'fw-base5))
    (set-face-attribute 'eh/org-keyword-answer nil
                        :foreground (doom-color 'fw-blue))
    (set-face-attribute 'eh/org-keyword-yes nil
                        :foreground (doom-color 'fw-green))
    (set-face-attribute 'eh/org-keyword-no nil
                        :foreground (doom-color 'fw-red))
    (set-face-attribute 'eh/org-keyword-meh nil
                        :foreground (doom-color 'fg-alt))
    (set-face-attribute 'eh/org-keyword-done nil
                        :foreground (doom-color 'fg-alt))
    (set-face-attribute 'eh/org-keyword-kill nil
                        :foreground (doom-color 'fg-alt))
    )
  )

  ;; (eh/org-update-theme)
#+end_src
** Basic configuration :org:
#+begin_src elisp
  (use-package org
    :config
    (eh/define-org-keywords)
    (eh/org-update-theme)
    ;; :init
    (setq org-directory "~/Org/"
          org-agenda-files '("~/Org/")
          org-refile-targets '((org-agenda-files . (:maxlevel . 5)))
          org-log-done t
          org-log-into-drawer t
          org-insert-heading-respect-content t
          org-M-RET-may-split-line '((default . t))
          org-todo-fast-selection 'expert
          org-cycle-separator-lines 1 ;; 2 blank lines to keep when collapsed
          org-indent-mode-turns-on-hiding-stars nil
          org-hide-leading-stars nil
          org-ellipsis " ↵" ;; ↵⏎¶
          org-fontify-whole-block-delimiter-line nil
          org-fontify-whole-heading-line nil
          org-fontify-todo-headline t
          org-fontify-done-headline t
          org-src-preserve-indentation t
          org-use-fast-todo-selection 'expert
          org-startup-truncated t
          org-element-use-cache nil)

    (setq org-src-window-setup 'current-window)
    (setq org-todo-keywords
          '((sequence "BURY(b)" "NEXT(n)" "TODO(t)" "HALT(h)" "|" "DONE(d!)" "KILL(k@)")
            (sequence "QUEST(q)" "|" "MEH(m)" "YES(Y)" "NO(N)" "ANSWER(a@)")
            (type "IDEA(i)" "YAKS(y)" "GOAL(g)" "|")
            ))

    (setq org-capture-templates
          '(("t" "Some thing" entry (file "~/Org/inbox.org")
             "* TODO %?\n%a\n%i")
            ("w" "Work thing" entry (file+headline "~/Org/dox-23Q1.org" "Inbox")
             "* TODO %?\n%a\n%i")
            ("y" "Yaks thing" entry (file+headline "~/Org/yaks.org" "Inbox")
             "* YAKS %?\n%a\n%i")
            ("b" "Key binding" entry
             (file+headline "~/.scratch-config/revision.org" "Missing bindings")
             "* TODO Binding for %?")
            ))

    ;; Each function will be called with no arguments.  The function
    ;; must check if the context is appropriate for it to act.  If yes,
    ;; it should do its thing and then return a non-nil value.  If the
    ;; context is wrong, just do nothing and return nil.
    (defun eh/hook-edit-src-block ()
      (cond ((org-in-src-block-p) (org-edit-src-code))))
    :general
    (:keymap 'org-src-mode-map "C-c C-c" #'org-edit-src-exit)
    :hook
    (org-mode . (lambda()
                  (org-indent-mode t)
                  (visual-line-mode t)
                  ;; (mixed-pitch-mode t)
                  ))
    (after-enable-theme . eh/org-update-theme)
    (org-ctrl-c-ctrl-c . eh/hook-edit-src-block)
    )
#+end_src
** Making org prettier :org_superstar:
#+begin_src elisp
(use-package org-superstar 
  :config
  (setq org-superstar-cycle-headline-bullets nil
        org-superstar-special-todo-items t
        org-superstar-leading-fallback "·"
        org-superstar-leading-bullet "·"
        org-superstar-remove-leading-stars nil
        org-superstar-headline-bullets-list '("◆" "•")
        org-superstar-prettify-item-bullets nil
        )
  (defun eh/org-superstar-update-theme ()
    (set-face-attribute 'org-superstar-header-bullet nil :weight (face-attribute 'default :weight) :font (face-attribute 'fixed-pitch :font))
    (set-face-attribute 'org-superstar-leading nil :foreground (face-attribute 'org-hide :foreground))
    )
  ;; :init
  (eh/org-superstar-update-theme)
  :hook 
  (org-mode . org-superstar-mode)
  (after-enable-theme . eh/org-superstar-update-theme)
  )
#+end_src
** Making org more powerful
*** For retrieving information :org_super_agenda:
The agenda is a big part of the power of org.
#+begin_src elisp
(use-package org-super-agenda)
#+end_src

Here's some fiddling trying to get a nice agenda going:
#+begin_src elisp :tangle no
(let ((org-super-agenda-groups
       '(
         (:discard (:tag "meta"))
         (:name "Today" ; the name of the section
                ;; :time-grid t ; items that go on the time grid
                :deadline (past today)
                :scheduled (past today)
                :priority "A") ; high priority items
         (:name "Follow Up"
                :todo ("BLOCK" "BLOK" "QSTN")) ; wait? hold?
         )))
  (org-agenda nil "t"))
#+end_src
* Language support
** Misc small packages :fish:haml:slim:
#+begin_src elisp
(use-package fish-mode)
(use-package haml-mode)
(use-package slim-mode)
#+end_src
** Writing in Markdown :markdown:
As much as I love org, sometimes I do still have to deal with Markdown. And it's usually github-flavored, so we'll need a package for that.
#+begin_src elisp
(use-package markdown-mode
  :mode
  (("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . gfm-mode))
  ;; :hook
  ;; (gfm-mode . mixed-pitch-mode)
  ;; (markdown-mode . mixed-pitch-mode)
  )
#+end_src
** Javascript with Vue :vue:
I think vue-mode gets us most of what we need. It handles markup and JS in the same file, which is the main thing. In some cases, web-mode can be better, since it supports reasonable folding for HTML elements. It's also useful to have for non-vue mixed-language templates.
#+begin_src elisp
(use-package vue-mode)
(use-package web-mode)
#+end_src
* Things that don't work right [4/8]
:PROPERTIES:
:visibility: folded
:END:
** Missing bindings :bind:
*** TODO Binding for ~org-capture~
*** TODO Binding for ~org-agenda~
*** KILL Binding for ~bury-buffer~
CLOSED: [2022-04-28 Thu 16:04]
:LOGBOOK:
- State "KILL"       from "TODO"       [2022-04-28 Thu 16:04] \\
  Duplicate
:END:
*** TODO Binding for ~eh/toggle-window-split~
Nothing seems to be bound to =C-x w= which could be a prefix for these window arrangement things
*** TODO Binding for ~crux-swap-windows~
*** DONE Binding for ~bury-buffer~ could be =C-z= which is currently ~suspend-frame~
CLOSED: [2022-04-28 Thu 16:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-28 Thu 16:03]
:END:
** BURY Something is getting the todo keyword colors stuck in weird states
The automatic theme change might be where things are going wrong. Or maybe it's modus. It seems like ... wait ... I did a few switches in a row and now the keyword colors are gone entirely.
- Loaded isohedron with =M-x load-theme= and everything looks good
I suspect I need to do something smarter with my various ~set-face-attribute~ calls. They get overridden by themes, but they don't ever get explicitly unset, so they tend to interact strangely. 
** TODO tab after fold indicator
** DONE persistent scratch can get lost in some situations
CLOSED: [2022-04-17 Sun 20:52]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-17 Sun 20:52]
:END:
It needs backup. I saw some sort of dismissive comment about how you just need to have it, but it's not actually clear /how/ to have it. Was is a different package?
** DONE Use expert mode for todo state input
CLOSED: [2022-04-17 Sun 20:34]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-17 Sun 20:34]
:END:
** BURY footnote inside table messes up alignment (mixed pitch hierarchy issue)
Footnote face inherits from button (in modus)
This same issue exists in Isohedron and that face just sets a foreground
This is something to do with org faces overlapping... there's a lot of weird there
** DONE Out with centaur-tabs, in with bufler
CLOSED: [2022-04-17 Sun 19:18]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-17 Sun 19:18]
:END:
*** DONE Get rid of centaur-tabs
CLOSED: [2022-04-16 Sat 11:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-16 Sat 11:47]
:END:
*** KILL Set up some keybindings for bufler
CLOSED: [2022-04-17 Sun 19:18]
:LOGBOOK:
- State "KILL"       from "TODO"       [2022-04-17 Sun 19:18]
:END:
** DONE Configure the more secondary consult functions
CLOSED: [2022-04-17 Sun 14:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-17 Sun 14:28] \\
  There's more I'd like to do, specifically in projects, but this gets the basic buffer functions set up
:END:
For instance, =C-x b= uses ~consult-buffer~ but =C-x 4 b= uses the default
** TODO When org marks something as done and that gives it content for the first time, it should be automatically folded
If it's already folded, it stays that way, so it does think about folding (I think?)
** Pulsar additions
*** TODO Add a highlight (persistent) to headline during ~org-archive-subtree-default~
*** TODO Pulse when cycling org headlines scrolls the buffer
** Commands to unbind :bind:
These case-changers just litter files I visit with random case-changes.
- =M-l= downcase-word (=C-x C-l= is downcase-region, there's unbound ~capitalize-dwim~ that will do region or word)
- =M-c= capitalize-word
- =M-u= upcase-word
** IDEA Put tags on headline with the names of packages/modes
Another option might be to put names on all the source blocks and navigate by those somehow
Starting to add this, and while I like the look, it seems like they'll get out of date
* Footnotes

[fn:1] ~org-babel-demarcate-block~
Make sure there's some content (not just whitespace) between the point and the last source block, or weird things happen. In that case, you can also select a region before the command to wrap it in a source block, which seem consistently reliable. The upside of the weirdness is that this same command, inside of a source block, will split it into two separate ones at point.
