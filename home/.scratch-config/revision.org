#+title: Streamline literate config
#+startup: show2levels
#+ARCHIVE: ~/Org/archive.org::* From %s

* Commentary
:PROPERTIES:
:visibility: folded
:END:
** On early initialization
My previous approach auto-tangled this out of the same file as everything else. It's not something that I revist often or have all that much commentary on. I think it's OK to have that outside of the tangled file, because I /think/ that the approach then becomes tangling the config on startup.
** Startup speed and servers
I definitely like keeping a server running. I think I'd like to make it easier to leave the server running without a frame, but maybe there's really not that much need.
I think terminal for things like git commit message? I wonder if you could make it open the magit changes view alongside it in terminal
** Why I'm rewriting this
I've been using my scratch config full-time for a while, and I think I'm ready for a refactor now that I better understand what I do and don't need, and how it will all fit together
** Organization
I've found that I strongly dislike the huge blocks I end up writing for some of the more  complex packages. It puts too many things in one place to really do the literate thing. But I refuse to have individual blocks that aren't a complete sexp.
There are a couple options to deal with this. There's a sort of constant substitution thing, which requires listing out all the sections that will be inserted. What I want is to be able to use something like Rails' ~content-for~ directives. The sections I want correspond to the keywords of the ~use-package~ 
This could probably be done with a macro but that frightens me.
** Which emacs to use?
The options are basically emacs-plus or emacs-mac. Until recently, emacs-plus was the only /real/ option, since emacs-mac was stuck on 27, but now they both have 28.1 available
*** Advantages of emacs-mac
- Mostly ~mac-auto-operator-composition-mode~
*** Advantages of emacs-plus
- I'm not sure, but I get the impression it's more standard
- There are hooks for when system appearance changes between light and dark, and the title bar actually works without ~defaults write~ shennanigans
* Notes on key commands
:PROPERTIES:
:visibility: all
:END:
Not any particularly significance or sort order, just things I'm trying to learn:
| Prefix | Key           | Command                               |
|--------+---------------+---------------------------------------|
|        | =C-x n=       | prefix for narrowing commands         |
|        | =C-x n s=     | narrow to subtree                     |
|        | =C-x n p=     | narrow to page                        |
| =C-u=  | =C-x ==       | what-cursor-position                  |
|--------+---------------+---------------------------------------|
|        | =C-c C-v d=   | insert babel source block[fn:1]       |
|        | =C-c C-x b=   | indirect buffer of current subtree    |
|        | =C-c C-x C-a= | archive current subtree               |
| =C-u=  | =C-c C-x C-a= | ask about archiving children          |
|--------+---------------+---------------------------------------|
|        | =M-m=         | back-to-indentation                   |
|        | =M-n=         | (at prompt) next history item (guess) |
|--------+---------------+---------------------------------------|
|        | =M-s h .=     | highlight symbol at point             |

* Bootstrap straight and use-package
This is now done directly in =init.el= so that we pick up the straight-managed version of org instead of the built in one.
[[file:init.el][Check it out]]
* Built-in options for basic emacs configuration
Introduce myself to Emacs:
#+begin_src elisp
(setq user-full-name "Emily Hyland"
      user-mail-address "hello@duien.com")
#+end_src

Set up some very basic (and mostly self-explanatory) options:
#+begin_src elisp
(setq inhibit-startup-screen t
      sentence-end-double-space nil
      vc-follow-symlinks t
      dired-use-ls-dired nil
      fill-column 80
      tool-bar-mode -1
      toggle-scroll-bar -1
      mouse-wheel-tilt-scroll t
      custom-safe-themes t
      )
#+end_src

When we turn on visual line mode, turn off mouse wheel tilt scroll:
#+begin_src elisp
(defun eh/disable-horiz-scroll-with-visual-line ()
  (setq-local mouse-wheel-tilt-scroll (not visual-line-mode)))
(add-hook 'visual-line-mode-hook 'eh/disable-horiz-scroll-with-visual-line)
#+end_src


Putting these here instead of in =early-init= means we get a brief glimpse of the default window position, then resize, but it also means that they respect our actual font size.
#+begin_src elisp
;; (push '(width . 100) default-frame-alist)
;; (push '(height . 0.8) default-frame-alist)
;; (push '(min-height . 40) default-frame-alist)
;; (push '(top . 0.25) default-frame-alist)
;; (push '(left . 0.5) default-frame-alist)
(push '(ns-transparent-titlebar . t) default-frame-alist)
#+end_src

Always allow `y' instead of `yes' in all prompts
#+begin_src elisp
;; (defalias 'yes-or-no-p 'y-or-n-p)
(setq use-short-answers t)
#+end_src

If you type over a selection, delete it first
#+begin_src elisp
(delete-selection-mode t)
#+end_src
** Everything should always be UTF-8
#+begin_src elisp
(set-charset-priority 'unicode)
(setq locale-coding-system 'utf-8
      coding-system-for-read 'utf-8
      coding-system-for-write 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src
** Set up basic minor modes
#+begin_src elisp
(delete-selection-mode t)
(recentf-mode t)
(setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                        ,(expand-file-name "eln-cache/" user-emacs-directory)
                        ,(expand-file-name "etc/" user-emacs-directory)
                        ,(expand-file-name "var/" user-emacs-directory)))
(winner-mode t) ;; undo/redo window layout changes
(show-paren-mode t)
(display-time-mode -1)
(setq bookmark-set-fringe-mark nil)
(repeat-mode t)
#+end_src
*** QUEST What commands does repeat-mode work for? Does this replace my desire for hydra?
** Set up reasonable indentation defaults
Attempt to make indentation do sensible things:
#+begin_src elisp
(setq-default indent-tabs-mode nil) ;; never use tabs to indent
(setq-default tab-width 2)
(setq js-indent-level 2)
(setq tab-always-indent t
      require-final-newline t)
#+end_src

And let other people decide per-project values:
#+begin_src elisp
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src
** Prevent autosave and backup files littered everywhere
#+begin_src elisp
(setq backup-directory-alist
      '((".*" . "~/.emacs-backups")))
(setq auto-save-file-name-transforms
      '((".*" "~/.emacs-backups" t)))
(setq
 auto-save-default t
 version-control t     ; number each backup file
 backup-by-copying t   ; instead of renaming current file (clobbers links)
 delete-old-versions t ; clean up after itself
 kept-old-versions 5
 kept-new-versions 5
 auto-save-include-big-deletions t)
#+end_src
*** TODO This does not at all work. Look into the package that does it for you?
** Configure things for mac
Set up what seems to be the least annoying modifier key setup:
#+begin_src elisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
  (setq mac-control-modifier 'control))
#+end_src
** Technical bits
Some inside baseball options I don't really understand:
#+begin_src elisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
;; less noise when compiling elisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
(setq native-comp-async-report-warnings-errors nil)
(setq load-prefer-newer t)

  (setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
  (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
  (setq enable-local-variables :all)     ; fix =defvar= warnings

#+end_src
** Keybindings
*** The surprisingly complicated question of =ESC=
I don't want ESC as a modifier. When I was coming from vim/evil it was just too confusing and tripped me up all the time.
Advice would say use ~keyboard-escape-quit~ as the binding here, which is what's originally bound to =ESC-ESC-ESC= but that makes it too easy to end up closing additional windows, which is basically never what I want.It turns out, however, that ~keyboard-quit~ is not what I want either since it doesn't get me out of the minibuffer. UGH.
What I've ended up with is using ~keyboard-escape-quit~ but modifying it so that the function it calls to kill a buffer just beeps instead. I'm not sure if it actually beeps, though. Am I good at ignoring it, have I retrained myself better than expected, or does it just not work?
#+begin_src elisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq-default buffer-quit-function
	            #'(lambda () (beep)))
#+end_src
**** IDEA What if ~buffer-quit-function~ closed non-file-visiting buffers but left open any file-visiting? That might let it get out of help windows but not out of actual buffer layout.
*** Use general to set up keybindings in a friendlier way
#+begin_src elisp
(use-package general
  :demand t)
(general-define-key "<help> F" 'describe-face)
(general-define-key "C-x z" 'bury-buffer)
(global-unset-key (kbd "C-x m"))
#+end_src
* How it looks
** Set up typography
Typography in Emacs can be very fiddly. Some links that might help sometimes?
[[https://stackoverflow.com/questions/67555133/emacs-not-listing-semilight-fonts][Emacs and fontconfig disagree about font weights]]

*** With the Recursive font
Set up fixed and variable pitch fonts with very similar character. It's a dynamic font, but unfortunately Emacs doesn't actually know how to handle that. So for now, we use two separate sets of static configs.
#+begin_src elisp
(defun eh/set-recursive-fonts ()
  (set-face-attribute 'default nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Recursive Sans Casual Static"
                      :height 160 :weight 'normal)
  )
#+end_src
*** With Pragmata Pro
#+begin_src elisp
(defun eh/set-pragmata-fonts ()
  (set-face-attribute 'default nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  )
#+end_src

**** All the extra ligatures and things
For PragmataPro, there are so many additional ligatures and things that are beyond what's needed for other fonts. The normal ligature configuration will not be sufficient, so we'd need to add a couple things to really get it working

[[https://github.com/lumiknit/emacs-pragmatapro-ligatures][emacs-pragmatapro-ligatures]] package on Github should set everything up for the most recent version.

However, MyFonts is stupid, and so I'm missing one style (PragmataPro Liga Regular) in the lastest version. I can use the mono version, but it's missing some of the more complex things. It _might_ be possible to set up a fallback font?

[[https://stackoverflow.com/questions/6083496/how-do-you-specify-a-fallback-font-in-emacs][This StackOverflow post]] has some information about how to do that, but not sure if it will really work for this weird situation.
*** With Plex fonts
#+begin_src elisp
(defun eh/set-plex-fonts ()
  (set-face-attribute 'default nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "iA Writer Quattro V"
                      :height 160 :weight 'semilight)
  )
#+end_src
*** With Input fonts
#+begin_src elisp
(defun eh/set-input-fonts ()
  (set-face-attribute 'default nil
                      :family "Input Mono Condensed"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :family "Input Mono Condensed"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :family "Input Sans Condensed"
                      :height 160 :weight 'normal)
  )
#+end_src
*** With Sudo fonts
#+begin_src elisp
(defun eh/set-sudo-fonts ()
  (set-face-attribute 'default nil
		      :font "Sudo"
		      :height 200 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
		      :font "Sudo"
		      :height 200 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
		      :font "Sudo UI"
		      :height 200 :weight 'normal))
#+end_src
*** Combinations with Victor

Victor and Galix are a fun combo.
#+begin_src elisp
(defun eh/set-victor-galix-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Galix"
                      :height 170 :weight 'normal)
  )
#+end_src

#+begin_src elisp
(defun eh/set-victor-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 170 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 170 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Overpass"
                      :height 170 :weight 'semilight)
  )
#+end_src
*** Belinsky
#+begin_src elisp
(defun eh/set-belinsky-fonts ()
  (set-face-attribute 'default nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  )
#+end_src
*** MonoLisa
MonoLisa is such a good font. The script version (installed as "MonoLisa Script") is also very good, but can be a little overwhelming for longer blocks of text. It might be interesting to try using both the italic and the script for different faces.
#+begin_src elisp
(defun eh/set-monolisa-fonts ()
  (set-face-attribute 'default nil
                      :family "MonoLisa Custom"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "MonoLisa Custom"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "MonoLisa Custom"
                      :height 160 :weight 'light)
  )
#+end_src
*** Cascadia
#+begin_src elisp
(defun eh/set-cascadia-fonts ()
  (set-face-attribute 'default nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  )
#+end_src
*** With Operator fonts
#+begin_src elisp
(defun eh/set-operator-fonts ()
  (set-face-attribute 'default nil
                      :font "Operator Mono SSm"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Operator Mono SSm"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Operator Mono SSm"
                      :height 160 :weight 'light)
  )
#+end_src
*** With Codelia
#+begin_src elisp
(defun eh/set-codelia-fonts ()
  (set-face-attribute 'default nil
                    :font "Codelia Ligatures"
                    :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                    :font "Codelia Ligatures"
                    :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                    :font "Codelia Ligatures"
                    :height 160 :weight 'normal))
#+end_src
*** With Apple fonts
#+begin_src elisp
(defun eh/set-simple-apple-fonts ()
  (set-face-attribute 'default nil
                      :font "SF Mono"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'fixed-pitch nil
                      :font "SF Mono"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'variable-pitch nil
                      :font "SF Pro Text"
                      :height 160 :weight 'semilight)
  )
(defun eh/set-fancy-apple-fonts ()
  (set-face-attribute 'org-document-title nil
                      :font "New York Extra Large"
                      :height 2.0 :weight 'bold)
 
  (set-face-attribute 'org-level-1 nil
                      :family "New York Medium"
                      :weight 'semibold :height 1.4)
  ;; Causing issues with line-height on TODO items
  ;; (set-face-attribute 'org-level-2 nil
  ;;                     :family "New York Medium"
  ;;                     :weight 'semibold
  ;;                     :height 1.2)
  (set-face-attribute 'org-ellipsis nil
                    :font "SF Mono"
                    :inherit '(shadow default))
  )
(defun eh/set-apple-fonts ()
  (eh/set-simple-apple-fonts)
  (eh/set-fancy-apple-fonts)
  )
#+end_src
*** With JetBrains
#+begin_src elisp
(defun eh/set-jetbrains-fonts ()
  (set-face-attribute 'default nil
                      :family "JetBrains Mono"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "JetBrains Mono"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "JetBrains Mono"
                      :height 160 :weight 'light)
  )
#+end_src
*** With Attribute fonts
#+begin_src elisp
(defun eh/set-attribute-fonts ()
  (set-face-attribute 'default nil
                      :family "Attribute Mono"
                      :height 160 :weight 'regular)
  (set-face-attribute 'fixed-pitch nil
                      :font "Attribute Mono"
                      :height 160 :weight 'regular)
  (set-face-attribute 'variable-pitch nil
                      :font "Attribute Mono"
                      :height 160 :weight 'regular)
  )
#+end_src
*** With the ridiculous Comic Code
#+begin_src elisp
(defun eh/set-comic-code-fonts ()
  (set-face-attribute 'default nil
                      :family "Comic Code Ligatures"
                      :height 160 :weight 'regular)
  (set-face-attribute 'fixed-pitch nil
                      :family "Comic Code Ligatures"
                      :height 160 :weight 'regular)
  (set-face-attribute 'variable-pitch nil
                      :family "Comic Code Ligatures"
                      :height 160 :weight 'regular)
  (set-face-attribute 'fixed-pitch-serif nil
                      :family "Comic Code Ligatures"))
#+end_src

*** And finally, enable a font!
#+begin_src elisp
;; (eh/set-recursive-fonts)
;; (eh/set-pragmata-fonts)
;; (eh/set-plex-fonts)
;; (eh/set-victor-fonts)
;; (eh/set-input-fonts)
;; (eh/set-sudo-fonts)
;; (eh/set-simple-apple-fonts)
;; (eh/set-monolisa-fonts)
;; (eh/set-jetbrains-fonts)
(eh/set-comic-code-fonts)
;; (add-hook 'after-enable-theme-hook #'eh/set-apple-fonts)
#+end_src

Interestingly, it turns out that ~mixed-pitch-mode~ doesn't deal well with changing fonts after the fact (even after toggling the mode)

But ~variable-pitch-mode~ seems to do just fine with it. I think I switched because of ... some very specific issues. Let's go back to variable for a while?

I've left mixed installed, but [[*Basic configuration][the org-mode hook configuration]] is what controls what we actually use. It's also set in [[*Writing in Markdown][markdown/gfm mode configuration]] as well.
*** Set up ligatures in various ways
Turn on automatic ligatures if the feature is available:
#+begin_src elisp
(when (fboundp 'mac-auto-operator-composition-mode)
  (setq mac-auto-operator-composition-characters "!\"#$%&'()+,-./:;<=>?@[\\]^_`{|}~w")
  (mac-auto-operator-composition-mode))
#+end_src

Or turn it on the hard way:
#+begin_src elisp
(use-package ligature
  :if (not (fboundp 'mac-auto-operator-composition-mode))
  :straight
  '(ligature :type git :host github
             :repo "mickeynp/ligature.el")
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable some common and uncommon ligature in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"
                                       "[FAIL]" "[BUG]" "[DEBUG]" "[ERR]" "[ERROR]" "[FAIL]" "[FATAL]"
                                       "[FIXME]" "[HACK]" "[INFO]" "[INFO ]" "[KO]" "[MARK]" "[NOTE]"
                                       "[OK]" "[PASS]" "[PASS ]" "[TODO]" "[TRACE]" "[VERBOSE]"
                                       "[WARN]" "[WARN ]" "[WARNING]"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t)
  )
#+end_src
** Color Theming
*** Set up a hook that's  run after loading a theme
Any theme customization that's done with ~set-face-attribute~ gets lost whenever we switch themes.  Usually you'd solve that with customize, but I kind of hate it. So, instead, we create our own hook taht's run on theme change to set those sorts of things.
#+begin_src elisp
(defvar after-enable-theme-hook nil
   "Normal hook run after enabling a theme.")

(defun run-after-enable-theme-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'after-enable-theme-hook))

(advice-add 'enable-theme :after #'run-after-enable-theme-hook)
#+end_src
*** Set up Modus
First, define a few functions that are useful to our use of Modus:
#+begin_src elisp
(defun eh/modus-customize ()
  (set-face-attribute 'font-lock-string-face nil :slant 'italic)
  ;; (set-face-attribute 'org-document-title nil :height 1.5)
  ;;(set-face-attribute 'window-divider nil
  ;;                    :foreground (modus-themes-color 'bg-main))
  ;;(set-face-attribute 'window-divider-first-pixel nil
  ;;                    :foreground (modus-themes-color 'bg-main))
  ;;(set-face-attribute 'window-divider-last-pixel nil
  ;;                    :foreground (modus-themes-color 'bg-main))

  ;; for mini-frame-mode, match border to child frame background
  (set-face-attribute 'child-frame-border nil
                      :background (modus-themes-color 'bg-inactive))
  ;; (set-face-attribute 'org-agenda-structure nil
  ;;                     :background 'unspecified
  ;;                     :foreground 'unspecified
  ;;                     :inherit '(modus-themes-markup-macro))
  (set-face-attribute 'header-line nil
                      :background (modus-themes-color 'bg-main))
  )

(defun eh/load-theme (appearance)
  "Load theme, taking current system APPEARANCE into consideration."
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (modus-themes-load-operandi))
    ('dark (modus-themes-load-vivendi))))

(defun eh/org-update-modus-theme ()
  (set-face-attribute 'org-done nil :weight 'normal)
  (set-face-attribute 'org-headline-todo nil
                      :weight 'normal
                      :foreground nil)
  (set-face-attribute 'org-headline-done nil
                      :weight 'normal
                      :foreground (modus-themes-color 'fg-window-divider-inner)
                      :inherit '(font-lock-comment-face))
  (set-face-attribute 'eh/org-keyword-todo nil
                      :inherit '(modus-themes-refine-green org-todo))
  (set-face-attribute 'eh/org-keyword-next nil
                      :background (modus-themes-color 'yellow-graph-0-bg)
                      :foreground (modus-themes-color 'orange-intense)
                      :inherit '(org-todo))
  (set-face-attribute 'eh/org-keyword-halt nil
                      :inherit '(modus-themes-intense-red org-todo))
  (set-face-attribute 'eh/org-keyword-bury nil
                      :inherit '(modus-themes-intense-neutral org-done))
  (set-face-attribute 'eh/org-keyword-question nil
                      :inherit '(modus-themes-refine-blue org-todo))
  (set-face-attribute 'eh/org-keyword-idea nil
                      :inherit '(modus-themes-refine-magenta org-todo))
  (set-face-attribute 'eh/org-keyword-read nil
                      :inherit '(modus-themes-special-warm org-todo))
  (set-face-attribute 'eh/org-keyword-done nil
                      :inherit '(modus-themes-nuanced-green org-done)
                      :foreground (modus-themes-color 'green-faint))
  (set-face-attribute 'eh/org-keyword-kill nil
                      :inherit '(modus-themes-nuanced-red org-done)
                      :foreground (modus-themes-color 'red-faint))
  (set-face-attribute 'eh/org-keyword-answer nil
                      :inherit '(modus-themes-nuanced-blue org-done)
                      :foreground (modus-themes-color 'blue-faint))
  (set-face-attribute 'eh/org-keyword-meh nil
                      :inherit '(modus-themes-subtle-neutral org-done))
  (set-face-attribute 'eh/org-keyword-yes nil
                      :inherit 'eh/org-keyword-done
                      :foreground (modus-themes-color 'green))
  (set-face-attribute 'eh/org-keyword-no nil
                      :inherit 'eh/org-keyword-kill
                      :foreground (modus-themes-color 'red))
  (set-face-attribute 'eh/org-keyword-rode nil
                      :inherit '(modus-themes-nuanced-yellow org-done))
  )
#+end_src

#+begin_src elisp
(use-package modus-themes
  :config
  (setq modus-themes-mixed-fonts t
        modus-themes-variable-pitch-ui nil ;; bad w/ nano
        modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-subtle-line-numbers t
        modus-themes-markup '(background intense)
        modus-themes-links '(background)
        modus-themes-fringes nil ;; background of fringe area
        modus-themes-mode-line '(accented)
        modus-themes-syntax '(green-strings)
        modus-themes-org-blocks 'gray-background
        modus-themes-completions '((t background intense accented))
        modus-themes-region '(bg-only accented)
        modus-themes-org-agenda '((header-block . (no-scale))
                                  (header-date . (bold-today underline-today))
                                  (scheduled . (rainbow))
                                  (event . (varied italic)))
        )
  ;; (add-hook 'ns-system-appearance-change-functions #'eh/load-theme)
  :init
  (modus-themes-load-themes)
  :hook
  ;; (modus-themes-after-load-theme . eh/set-apple-fonts)
  (modus-themes-after-load-theme . eh/modus-customize)
  )
#+end_src
*** Set up some alternate color themes
#+begin_src elisp
(use-package iodine-theme)
(use-package poet-theme
  :config
  (setq poet-theme-variable-headers nil
        poet-theme-variable-pitch-multiplier 1))
(use-package spacemacs-theme
  :custom
  (spacemacs-theme-comment-bg nil)
  (spacemacs-theme-comment-italic t)
  (spacemacs-theme-org-height nil))
(use-package solo-jazz-theme)
(use-package flucui-themes)
(use-package doom-themes
  :config
  (setq doom-isohedron-brighter-modeline t)
  (setq doom-earl-grey-brighter-modeline t)
  )
(use-package nano-theme)
(use-package bespoke-theme
  :straight (:host github :repo "mclear-tools/bespoke-themes" :branch "main"))

(use-package ef-themes
  :preface
  (defun eh/get-ef-color (name)
    (car (cdr (assoc name (ef-themes--current-theme-palette)))))
  :straight (:type git :host github :repo "protesilaos/ef-themes")
  :config
  (setq ef-themes-headings
        '((0 . (1.8))
          (1 . (1.3)))))

(use-package kaolin-themes
  :config
  (setq kaolin-themes-italic-comments t))

(use-package isohedron-theme
  :straight (:type git :host github :repo "duien/isohedron-theme"))

;; (modus-themes-load-operandi)
(load-theme 'ef-day)
;; (load-theme 'kaolin-breeze)
#+end_src
*** Fancy and unnecessary SVG tags
#+begin_src elisp
(use-package svg-lib)
(use-package svg-tag-mode
  :straight (:type git :host github :repo "rougier/svg-tag-mode")
  :config
  (setq svg-tag-tags
      '((":TODO:" . ((lambda (tag) (svg-tag-make "TODO")))))))
#+end_src
** Interface
*** IDEA Make the mark always visible
This is a start. It adds the ability to visualize the mark, but (at least with transient-mark-mode) it only seems to show them when the mark is active.
#+begin_src elisp
(use-package visible-mark
  :config
  (setq visible-mark-max 5)
  :init
  ;; (global-visible-mark-mode 1)
  )
#+end_src
*** Use mixed pitch fonts
#+begin_src elisp
(use-package mixed-pitch
  :ensure t)
#+end_src
This is really determined by which mode we load in org. I'd been using variable-pitch-mode but it's doing something weird with tables (every character I check says it's mono, but the lines don't line up). I think overall mixed-pitch-mode works better, but had some compatibility issues, possibly involving dimmer and/or changing fonts.
*** Show horizontal rules instead of =^L= 
#+begin_src elisp
(use-package form-feed
  :ensure t
  :init
  (form-feed-mode t))
#+end_src
-
*** A better mode-line
#+begin_src elisp
(use-package nano-modeline
  :config
  (setq nano-modeline-position 'top
        nano-modeline-space-top 0.15 ;; 0.15
        nano-modeline-space-bottom -0.2 ;; -0.2
        nano-modeline-prefix-padding t
        nano-modeline-prefix 'status)
  ;; :hook (after-init . nano-modeline-mode)
  )

;; removing information from the mode line
(setq mode-line-percent-position nil)
(line-number-mode -1)

(use-package moody
  :config
  (setq x-underline-at-descent-line t
        moody-mode-line-height nil)
  ;; :init
  ;; (moody-replace-mode-line-buffer-identification)
  )
#+end_src

Use minions to hide all the minor mode indicators in a menu
#+begin_src elisp
(use-package minions
  :config
  (setq minions-mode-line-lighter "≡")
  :init (minions-mode 1))
#+end_src
*** A menu of keybindings when you pause
#+begin_src elisp
(use-package which-key
  :config
  ;; this is the default
  (which-key-setup-side-window-bottom)
  :init
  (which-key-mode))
#+end_src
*** Make help more helpful
#+begin_src elisp
(use-package helpful
  :general
  ("C-h f" 'helpful-callable)
  ("C-h v" 'helpful-variable)
  ("C-h k" 'helpful-key)
  ("C-h C" 'helpful-command) ;; only interactive functions
  ;; this is overwritten by set-deadline in org
  ("C-c C-d" 'helpful-at-point)
  )
#+end_src
*** Selectively dim windows
It's a choice between solaire, which dims non-file-visiting buffers, and dimmer, which dims inactive buffers. Wouldn't rule-based buffer colors be cool?
**** BURY Solaire
**** Dimmer
#+begin_src elisp
(use-package dimmer
  :config
  (setq dimmer-fraction 0.3) ;; this is right for isohedron
  (dimmer-configure-which-key)
  (dimmer-configure-org)
  (dimmer-configure-magit)
  ;; (dimmer-configure-posframe)
  ;; (dimmer-configure-hydra) ;; ??
  ;; :init (dimmer-mode 1)
  )
#+end_src
*** Show the minibuffer somewhere more visible
#+begin_src elisp
(use-package mini-frame
  :config
  (setq mini-frame-background-color-function
        (lambda ()
          (face-attribute 'mode-line-inactive :background)))
  (setq mini-frame-show-parameters
        '((child-frame-border-width . 8) ;; give it breathing room
          (no-accept-focus . t) ;; makes initial height work correctly
          (left . 0.5) ;; center horizontally
          (top . 0.25) ;; about a quarter down
          (width . 0.8) ;; narrower than the frame usually
          (min-width . 60) ;; never too narrow
          (height . 1) ;; default to one line
          (min-height . 1) ;; it can be as little as it wants
          (keep-ratio . t) ;; keep proportion as parent resizes
          (left-fringe . 8) ;; extra side padding
          (right-fringe . 8) ;; for both sides
          ))
  (setq mini-frame-resize t)
  :init
  ;; (mini-frame-mode t)
  )
#+end_src
*** Tweak frame display
This uses a background-color column to divide windows instead of drawing a line:
#+begin_src elisp
;; (use-package frame
;;   :straight (:type built-in)
;;   :custom
;;   (window-divider-default-right-width 12)
;;   (window-divider-default-bottom-width 1)
;;   (window-divider-default-places 'right-only)
;;   (window-divider-mode t)
;;   :hook
;;   (before-make-frame . window-divider-mode))
#+end_src
* What it can do
** Vertical completion interface
This is what's used when switching buffers, searching for files, refiling to an org headline, all that stuff.
*** Set up consult first
Consult is what sets the contents of those menus. It provides a really nice buffer switch interface, ~consult-buffer~, which includes a variety of sources and the ability to use a single-letter prefix to filter them exclusively.
#+begin_src elisp
  (use-package consult
    :demand t
    :config
    ;; Don't automatically preview things
    (setq consult-preview-key (kbd "M-."))
    ;; :init
    (setq consult-project-root-function #'projectile-project-root)
    :general
    ("C-x b" 'consult-buffer)
    ("C-x 4 b" 'consult-buffer-other-window)
    ("C-x 5 b" 'consult-buffer-other-frame)
    ;; consult-yank-from-kill-ring
    ;; consult-yank-pop
    ("<help> a" 'consult-apropos)
    ("<help> t" 'consult-theme))
#+end_src

It still only operates on the single line, but it provides the nicer menus, and allows previewing the thing to be switched to (buffers, themes, etc).
*** Set up vertico
Vertico is what takes the completion functions from consult and turns them into what we'd normally think of as an autocomplete window. It's a few lines high, shows the input at the top, and provides a list of the possible results. You can move up and down through the list, or continue typing to keep narrowing.
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode))
#+end_src
*** Use orderless matching
Speaking of matching, it's something that apparently I have Opinions about. It's important for the way I use it (and the organization of the projects I'm often navigating) that I can add additional elements to the match out of order. I might start searching for a model, =mod= then =us= for user. Oh, but I need the spec, so =spec=. In a lot of completion setups, I'd have to go back to the beginning of the string to add a filter that's higher up in the file tree. But with orderless, I can add the tokens in whatever order I want!
In order for that not to make the search space too big, I then have to separate the tokens with spaces. It can sometimes be annoying, but it's sometimes actually useful for disambiguation.
#+begin_src emacs-lisp
(use-package orderless
  :config
  (defun flex-if-twiddle (pattern _index _total)
    (when (string-suffix-p "~" pattern)
      `(orderless-flex . ,(substring pattern 0 -1))))

  (defun without-if-bang (pattern _index _total)
    (cond
     ((equal "!" pattern)
      '(orderless-literal . ""))
     ((string-prefix-p "!" pattern)
      `(orderless-without-literal . ,(substring pattern 1)))))
  :init
  (setq orderless-matching-styles '(orderless-regexp)
        orderless-style-dispatchers '(without-if-bang flex-if-twiddle))
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Show marginalia when completing
This adds the additional columns to the completion window. Extra info, and I think it fixes an alignment issue with variable pitch fonts.
#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode))
#+end_src
** Scratch buffer is magic
I use the scratch buffer a lot, and it's nice to have the things there stick around unless I delete them on purpose. It's a good place to stash log output, temporary shell command editing, things like that, but sometimes I need to restart my editor while still in the middle of those tasks.
#+begin_src elisp
(use-package persistent-scratch
  :demand t
  :config
  (setq persistent-scratch-backup-directory "~/.emacs-backups")
  :init
  (persistent-scratch-setup-default)
  (persistent-scratch-mode 1))
#+end_src
** Version control
Set up the best git interface:
#+begin_src elisp
(use-package magit)
#+end_src

See which lines have been modified in the gutter
#+begin_src elisp
(use-package diff-hl
  :hook
  (magit-pre-refresh . diff-hl-magit-pre-refresh)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :init
  (global-diff-hl-mode 1))
#+end_src
** Use projects for organization
#+begin_src elisp
(use-package projectile
  :config
  (setq projectile-project-search-path
	'(("~/Code" . 3)
	  ("~/.homesick/repos" . 1)))
  (projectile-add-known-project "~/Org")
  (projectile-add-known-project "~/Notes")
  :general
  ("C-x p" '(:keymap projectile-command-map :package projectile))
  ("C-x p b" 'consult-project-buffer)
  :init
  (projectile-mode 1))
#+end_src
** A shell in the editor
#+begin_src elisp
(use-package vterm)
#+end_src

* Simple utilities for better editing
** Miscellaneous commands :crux:expand_region:rainbow:logos:olivetti:ws_butler:
Crux has lots of handy utility functions. These are a few of the best:
#+begin_src elisp
(use-package crux
  :general
  ("C-o" 'crux-smart-open-line)
  ("M-o" 'crux-smart-open-line-above)
  ("C-k" 'crux-smart-kill-line)
  )
#+end_src

Make the current window strongly dedicated to the current buffer (don't allow commands to replace the buffer). Main use case is a single-window frame that shows my org file and won't accidentally get replaced with something else when (for instance) opening a file from the command line.
#+begin_src elisp
(defun eh/anchor-buffer ()
  (interactive)
  (set-window-dedicated-p (get-buffer-window (current-buffer)) t))
#+end_src


Expanding the region incrementally is incredibly helpful:
#+begin_src elisp
(use-package expand-region
  :general
  ("C-=" 'er/expand-region))
#+end_src

Allow highlighting color-like things in their colors. This isn't very smart about things, and tends to highlight named colors in an annoying number of places, but when it's useful it's really useful.
#+begin_src elisp
(use-package rainbow-mode)
(use-package fontify-face)
#+end_src

Move forward and backward through pages when the buffer is narrowed:
#+begin_src elisp
(use-package logos
  :straight (logos :type git :host github :repo "protesilaos/logos")
  :config
  (setq logos-outlines-are-pages t)
  :general
  ([remap narrow-to-region] 'logos-narrow-dwim)
  ([remap forward-page] 'logos-forward-page-dwim)
  ([remap backward-page] 'logos-backward-page-dwim))
  
(use-package olivetti
  :config
  (setq olivetti-style nil))
#+end_src
Getting rid of ~visual-fill-column-mode~ in favor of olivetti. I think overall, having regular ~visual-line-mode~ is a better default, and olivetti is simple (and I can remember the dang name!)

Manage whitespace automatically:
#+begin_src elisp
(use-package ws-butler
  :hook
  (prog-mode . ws-butler-mode))
#+end_src
** Do better things with line wrapping
#+begin_src elisp
(use-package adaptive-wrap)
(setq-default word-wrap t)
(setq-default truncate-lines t)
#+end_src
** Parentheses matching and surround :smartparens:
#+begin_src elisp
(use-package smartparens
  :config
  :init
  (require 'smartparens-config)
  (smartparens-global-mode 1)
  )
#+end_src
** Toggle between vertical and horizontal split windows
#+begin_src elisp
(defun eh/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+end_src
** Pulse the line after movement :pulsar:
#+begin_src elisp
(use-package pulsar
  :config
  (setq pulsar-pulse nil ;; nil to leave the highlight in place until another command
        pulsar-delay 0.5 ;; how long each step lasts
        pulsar-iterations 1 ;; how many steps for color
        pulsar-face 'pulsar-yellow
        )
  :general
  ;; Bind pulsar-hightlight-dwim
  ;; Bind pulsar-pulse-line
  :init
  ;; (pulsar-global-mode 1)
  ;; (add-to-list 'pulsar-pulse-functions 'org-cycle)
  ;; (add-to-list 'pulsar-pulse-functions 'isearch-repeat-forward)
  ;; pulsar-face
  )
#+end_src
** Highlight occurrences of multiple symbols :highlight_symbol:
#+begin_src elisp
(use-package highlight-symbol)
;; highlight-symbol-mode for persistent highlights
;; highlight-symbol-nav-mode for M-n / M-p navigation through occurrences
;; highlight-symbol to highlight symbol at point
#+end_src
** TODO Don't silently kill buffers that don't have a file yet
It seems completely unreasonable that I'm trying to do this with buffer-name regexes. What I want is to prompt before killing (or mostly before quitting) if there's a buffer I've been writing things in that hasn't been saved.
But there's seemingly no reliable way to find out whether something is a real buffer without a file, or whether it's just a temporary/internal buffer other than ... regex.
#+begin_src elisp
;; (setq-default buffer-offer-save t)
(defun confirm-buffer-kill-modified ()
  (if (and
       (buffer-modified-p)
       (not (string-match-p "^ ?(\\*.+\\*(<.+>)?$)?"
                          (buffer-name)))
       )
    (yes-or-no-p
     (format "Buffer %S is modified; kill it?" (buffer-name)))
    t))

;; (add-hook 'kill-buffer-query-functions #'confirm-buffer-kill-modified)
#+end_src

* Set up org-mode
** Prepare for org configuration

Define custom faces for all of our keywords. This allows redone styles to be loaded without reload org-mode
#+begin_src elisp
(cl-defun eh/org-register-keyword (&key keywords face symbol)
  (dolist (key keywords)
    (add-to-list 'org-todo-keyword-faces `(,key . ,face))
    (add-to-list 'org-superstar-todo-bullet-alist `(,key . ,symbol))
    ))
#+end_src
** Define org keywords
I've been slowly refining this set of org keywords for a very long time. But that evolution also means that sometimes I forget what was the new meaning vs. the old meaning for things.

*** The keywords themselves
So, here are the keywords as they stand now, and what the intention is for each one. First the incomplete items and then the completed ones. Certain types of items tend to use certain types of completions, but it's not a hard and fast rule

**** TODO A task that needs to be done, or a problem that needs to be solved. No question about whether it's a good idea
**** IDEA Something to think about doing, but that requires investigation. Maybe it's not thought all the way through yet, maybe I'm not sure yet if it's a /good/ idea. Sort of like a spike for a programming project
**** READ A blog post or article that I think has information I want. It might fill in information I need to answer a question, or it might be inspiration for some new ideas or tasks
**** QUEST A question that needs an answer. Might be yes/no, might be something requiring research and producing some sort of output
**** BURY Is for things that have lost relevance or importance, but might come back later. The back-burner.
**** NEXT For a larger project, the thing to focus on to move it forward. Also a way to flag things that I want to get to soon, sort of like the star in Things. Possibly would be better represented by priority, but I like a separate keyword
**** HALT Something that needs to be moving forward but can't for some external reason. Basically means blocked, but is 4 letters long
**** DONE The basic successful completion of something. Used for basically anything other than questions
**** KILL Something that I've decided against doing or that is no longer relevant
**** YES is a fairly self-explanatory answer to questions
**** NO goes along with it
**** ANSWER records the results of a question that required more research. Likely to contain interesting and valuable things
**** MEH A question that I've decided I no longer care about. Either not worth answering or the answer no longer matters. The equivalent of kill
**** RODE would be a very silly past tense of read.
*** Define the keywords
  
#+begin_src elisp
(defun eh/define-org-keywords ()
  ;; Register all variations of keywords with faces and symbols
  ;; Only the ones included in `org-todo-keywords' will be
  ;; activated by default, but the others will still be styled
  ;; if activated by buffer properties

  ;; First, clear out (and register) the two lists we're building up
  (setq org-todo-keyword-faces '()
        org-superstar-todo-bullet-alist '())

  (eh/org-register-keyword
   :keywords '("DONE")
   :symbol ?- ;;✓
   :face (defface eh/org-keyword-done '((t :inherit org-done))
           "Face used for the DONE keyword in Org"))
  (eh/org-register-keyword
   :keywords '("KILL" "CANCEL")
   :symbol ?× ;; ✗ ;;× ×
   :face (defface eh/org-keyword-kill '((t :inherit org-done))
           "Face used for the KILL keyword in Org"))
  (eh/org-register-keyword
   :keywords '("ANSWER" "ANSR")
   :symbol ?·
   :face (defface eh/org-keyword-answer '((t :inherit org-done))
           "Face used for the ANSR keywork in Org"))
  (eh/org-register-keyword
   :keywords '("MEH" "OK")
   :symbol ?·
   :face (defface eh/org-keyword-meh '((t :inherit org-done))
           "Face used for the OK keyword in Org"))
  (eh/org-register-keyword
   :keywords '("YES")
   :symbol ?·
   :face (defface eh/org-keyword-yes '((t :inherit eh/org-keyword-done))
           "Face used for the YES keyword in Org"))
  (eh/org-register-keyword
   :keywords '("NO")
   :symbol ?·
   :face (defface eh/org-keyword-no '((t :inherit eh/org-keyword-kill))
           "Face used for the NO keyword in Org"))
  (eh/org-register-keyword
   :keywords '("RODE")
   :symbol ?·
   :face (defface eh/org-keyword-rode '((t :inherit 'org-done))
           "Face used for RODE keyword in Org"))
  (eh/org-register-keyword
   :keywords '("BURY" "WAIT" "HOLD" "LATER")
   :symbol ?~
   :face (defface eh/org-keyword-bury '((t :inherit org-todo))
           "Face used for the WAIT keyword in Org"))
  (eh/org-register-keyword
   :keywords '("NEXT" "FLAG")
   :symbol ?● ;;◯ ;;☐ ;; ?◦●
   :face (defface eh/org-keyword-next '((t :inherit org-todo))
           "Face used for the FLAG keyword in Org"))
  (eh/org-register-keyword
   :keywords '("TODO")
   :symbol ?○ ;;◯ ;;☐ ;; ?◦ ○
   :face (defface eh/org-keyword-todo '((t :inherit org-todo))
           "Face used for the TODO keyword in Org"))
  (eh/org-register-keyword
   :keywords '("HALT" "BLOK" "BLOCK")
   :symbol ?▲ ;;△ ;;◊▲
   :face (defface eh/org-keyword-halt '((t :inherit org-todo))
           "Face used for the BLOK keyword in Org"))
  (eh/org-register-keyword
   :keywords '("QUEST" "QSTN" "QUESTION")
   :symbol ?◊ ;;◇ ;;?
   :face (defface eh/org-keyword-question '((t :inherit org-todo))
           "Face used for the QSTN keyword in Org"))
  (eh/org-register-keyword
   :keywords '("IDEA" "YAKS" "YAK")
   :symbol ?♡ ;;◌ ;; ∞ ҩ ¤ φ
   :face (defface eh/org-keyword-idea '((t :inherit org-todo))
           "Face used for the IDEA keyword in Org"))
  (eh/org-register-keyword
   :keywords '("READ")
   :symbol ?◊ ;;◇
   :face (defface eh/org-keyword-read '((t :inherit org-todo))
           "Face used for the READ keyword in Org"))
  )
#+end_src
** Set up theme-specific org styling
Set up some basic org styling that we'll run whenever we change themes:
#+begin_src elisp
(defun eh/org-update-theme ()
  ;; default styling for task keywords
  ;; (set-face-attribute 'org-todo nil
  ;;                     :inherit 'fixed-pitch
	;; 	                  :box nil
	;; 	                  :height 1.0
  ;;                     :weight (face-attribute 'bold :weight))
  ;; (set-face-attribute 'org-done nil
  ;;                     :inherit 'fixed-pitch
  ;;          	          :slant 'italic
  ;;                     :weight (face-attribute 'default :weight))
  ;; (set-face-attribute 'eh/org-keyword-bury nil
  ;;                     :weight (face-attribute 'default :weight))

  ;; styling for headlines with keywords
  ;; (set-face-attribute 'org-headline-todo nil
  ;;                     :weight (face-attribute 'default :weight))
  ;; (set-face-attribute 'org-headline-done nil
  ;;                     :inherit '(font-lock-comment-face default))

  ;; this is not actually org-related but I'm lazy
  ;; (set-face-attribute 'window-divider nil
  ;;                     :foreground (face-attribute 'default :background))
  ;; (set-face-attribute 'window-divider-first-pixel nil
  ;;                     :foreground (face-attribute 'default :background))
  ;; (set-face-attribute 'window-divider-last-pixel nil
  ;;                     :foreground (face-attribute 'default :background))

  ;; set things up for mixed/variable pitch
  ;; (set-face-attribute 'org-hide nil :inherit 'fixed-pitch)
  ;; (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  ;; (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  ;; (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)

  ;; Unset the foreground and background of my org faces
  ;; and reset inheritance
  ;; try pulling the list from org-todo-keyword-faces
  (dolist (face
           '(eh/org-keyword-todo
             eh/org-keyword-question
             eh/org-keyword-idea
             eh/org-keyword-next
             eh/org-keyword-halt
             eh/org-keyword-read))
    (set-face-attribute face nil
                        :foreground 'unspecified
                        :background 'unspecified
                        :inherit 'org-todo))
  (dolist (face
           '(eh/org-keyword-bury
             eh/org-keyword-done
             eh/org-keyword-answer
             eh/org-keyword-yes
             eh/org-keyword-no
             eh/org-keyword-meh
             eh/org-keyword-kill
             eh/org-keyword-rode))
    (set-face-attribute face nil
                        :foreground 'unspecified
                        :background 'unspecified
                        :inherit 'org-done))
  
  ;; Now set up theme-specific things?
  (pcase (car custom-enabled-themes)
    ((or 'modus-operandi 'modus-vivendi)
     (message "Setting up org faces for Modus")
     (eh/org-update-modus-theme))
    ('doom-isohedron
     (message "Setting up org faces for Isohedron")
     (set-face-attribute 'org-todo nil
                         :foreground (doom-color 'bg)
                         :background (doom-color 'fw-base3))
     (set-face-attribute 'eh/org-keyword-todo nil
                         :background (doom-color 'fw-green))
     (set-face-attribute 'eh/org-keyword-question nil
                         :background (doom-color 'fw-blue))
     (set-face-attribute 'eh/org-keyword-idea nil
                         :background (doom-color 'fw-purple))
     (set-face-attribute 'eh/org-keyword-next nil
                         :foreground (doom-color 'fw-yellow-text)
                         :background (doom-color 'fw-yellow))
     (set-face-attribute 'eh/org-keyword-bury nil
                         :foreground (doom-color 'fg-alt)
                         :background (doom-color 'fw-base5))
     (set-face-attribute 'eh/org-keyword-answer nil
                         :foreground (doom-color 'fw-blue))
     (set-face-attribute 'eh/org-keyword-yes nil
                         :foreground (doom-color 'fw-green))
     (set-face-attribute 'eh/org-keyword-no nil
                         :foreground (doom-color 'fw-red))
     (set-face-attribute 'eh/org-keyword-meh nil
                         :foreground (doom-color 'fg-alt))
     (set-face-attribute 'eh/org-keyword-done nil
                         :foreground (doom-color 'fg-alt))
     (set-face-attribute 'eh/org-keyword-kill nil
                         :foreground (doom-color 'fg-alt))
     )
    ((pred (lambda (theme) (member theme ef-themes-light-themes)))
     (message "Setting up ef-theme overrides (light)")
     (set-face-attribute 'org-headline-todo nil
                         :inherit nil
                         :weight 'normal)
     (set-face-attribute 'org-headline-done nil
                         :inherit nil
                         :foreground (eh/get-ef-color 'fg-dim)
                         :slant 'italic
                         :weight 'normal)
     (set-face-attribute 'org-done nil
                         :weight 'normal
                         :foreground (eh/get-ef-color 'fg-dim)
                         :background (eh/get-ef-color 'bg-dim))
     (set-face-attribute 'eh/org-keyword-todo nil
                         :foreground (eh/get-ef-color 'green)
                         :background (eh/get-ef-color 'bg-green))
     (set-face-attribute 'eh/org-keyword-question nil
                         :foreground (eh/get-ef-color 'blue)
                         :background (eh/get-ef-color 'bg-blue))
     (set-face-attribute 'eh/org-keyword-idea nil
                         :foreground (eh/get-ef-color 'magenta)
                         :background (eh/get-ef-color 'bg-magenta))
     (set-face-attribute 'eh/org-keyword-next nil
                         :foreground (eh/get-ef-color 'yellow)
                         :background (eh/get-ef-color 'bg-yellow))
     (set-face-attribute 'eh/org-keyword-halt nil
                         :foreground (eh/get-ef-color 'red)
                         :background (eh/get-ef-color 'bg-red))
     (set-face-attribute 'eh/org-keyword-read nil
                         :foreground (eh/get-ef-color 'cyan)
                         :background (eh/get-ef-color 'bg-cyan))
     (set-face-attribute 'eh/org-keyword-bury nil
                         :foreground (eh/get-ef-color 'fg-main)
                         :background (eh/get-ef-color 'bg-alt))
     (set-face-attribute 'eh/org-keyword-kill nil
                         :foreground (eh/get-ef-color 'red-faint)
                         :background (eh/get-ef-color 'bg-removed-faint))
     (set-face-attribute 'eh/org-keyword-yes nil
                         :foreground (eh/get-ef-color 'green-faint)
                         :background (eh/get-ef-color 'bg-added-faint))
     (set-face-attribute 'eh/org-keyword-answer nil
                         :foreground (eh/get-ef-color 'blue-faint)
                         :background (eh/get-ef-color 'bg-blue-subtle))
     )
    ((pred (lambda (theme) (member theme ef-themes-dark-themes)))
     (message "Setting up ef-theme overrides (dark)")
     (set-face-attribute 'org-headline-todo nil
                         :inherit nil
                         :weight (face-attribute 'default :weight))
     (set-face-attribute 'org-headline-done nil
                         :inherit 'italic
                         :weight (face-attribute 'default :weight))
    (set-face-attribute 'eh/org-keyword-todo nil
                        :foreground (eh/get-ef-color 'bg-green-subtle)
                        :background (eh/get-ef-color 'green))
    (set-face-attribute 'eh/org-keyword-question nil
                        :foreground (eh/get-ef-color 'bg-blue-subtle)
                        :background (eh/get-ef-color 'blue))
    (set-face-attribute 'eh/org-keyword-idea nil
                        :foreground (eh/get-ef-color 'bg-magenta-subtle)
                        :background (eh/get-ef-color 'magenta))
    (set-face-attribute 'eh/org-keyword-next nil
                        :foreground (eh/get-ef-color 'bg-yellow)
                        :background (eh/get-ef-color 'yellow-graph-0-bg))
    (set-face-attribute 'eh/org-keyword-halt nil
                        :foreground (eh/get-ef-color 'bg-main)
                        :background (eh/get-ef-color 'red-graph-0-bg))
    (set-face-attribute 'eh/org-keyword-read nil
                        :foreground (eh/get-ef-color 'bg-dim)
                        :background (eh/get-ef-color 'fg-dim))
    (set-face-attribute 'org-done nil
                        :weight (face-attribute 'default :weight)
                        :foreground (eh/get-ef-color 'fg-dim)
                        :background (eh/get-ef-color 'bg-dim))
    (set-face-attribute 'eh/org-keyword-done nil
                        :foreground (eh/get-ef-color 'green-graph-1-bg))
    (set-face-attribute 'eh/org-keyword-kill nil
                        :foreground (eh/get-ef-color 'red-graph-1-bg))
    (set-face-attribute 'eh/org-keyword-answer nil
                        :foreground (eh/get-ef-color 'bg-blue))
    (set-face-attribute 'eh/org-keyword-yes nil
                        :inherit 'eh/org-keyword-done
                        :background (eh/get-ef-color 'bg-added))
    (set-face-attribute 'eh/org-keyword-no nil
                        :inherit 'eh/org-keyword-kill
                        :background (eh/get-ef-color 'bg-removed-faint))
    (set-face-attribute 'eh/org-keyword-answer nil
                        :background (eh/get-ef-color 'bg-blue-subtle)
                        :foreground (eh/get-ef-color 'blue-faint))
    (set-face-attribute 'eh/org-keyword-rode nil
                        :foreground (eh/get-ef-color 'cyan-graph-1-bg))
    )))

;; (eh/org-update-theme)
#+end_src
** Basic configuration :org:
#+begin_src elisp
(use-package org
  :config
  (eh/define-org-keywords)
  (eh/org-update-theme)
  ;; :init
  (setq org-directory "~/Org/"
        org-agenda-files '("~/Org/")
        org-refile-targets '((org-agenda-files . (:maxlevel . 5)))
        org-log-done t
        org-log-into-drawer t
        org-insert-heading-respect-content t
        org-M-RET-may-split-line '((default . t))
        org-cycle-separator-lines 1 ;; 2 blank lines to keep when collapsed
        org-indent-mode-turns-on-hiding-stars nil
        org-hide-leading-stars nil
        org-fontify-whole-block-delimiter-line nil
        org-fontify-whole-heading-line t
        org-fontify-todo-headline t
        org-fontify-done-headline t
        org-src-preserve-indentation t
        org-use-fast-todo-selection 'expert
        org-startup-truncated t
        org-element-use-cache nil
        org-element-cache-persist nil
        org-ctrl-k-protect-subtree t
        org-tags-column 0
        org-auto-align-tags nil
        org-fold-catch-invisible-edits 'show
        org-blank-before-new-entry '((heading . nil)
                                     (plain-list-item . nil)))
  ;; ↵ ⏎ ¶ ⌄ ▶ § ⋱ ◁ ◀ ∷ ⋯
  (setq org-ellipsis " ⋯")
  (setq org-src-window-setup 'current-window)
  (setq org-agenda-window-setup 'other-window
        org-agenda-restore-windows-after-quit t)
  (setq org-todo-keywords
        '((sequence "BURY(b)" "NEXT(n)" "TODO(t)" "HALT(h)" "|" "DONE(d!)" "KILL(k@)")
          (sequence "QUEST(q)" "|" "MEH(m)" "YES(Y)" "NO(N)" "ANSWER(a@)")
          (type "IDEA(i)" "GOAL(g)" "|")
          (sequence "READ(R)" "|" "RODE(r)")
          ))

  (setq org-capture-templates
        '(("t" "Some thing" entry (file "~/Org/inbox.org")
           "* TODO %?\n%a\n%i")
          ("w" "Work thing" entry (file+headline "~/Org/dox-23Q1.org" "Inbox")
           "* TODO %?\n%a\n%i")
          ("y" "Yaks thing" entry (file+headline "~/Org/yaks.org" "Inbox")
           "* TODO %?\n%a\n%i")
          ("b" "Key binding" entry
           (file+headline "~/.scratch-config/revision.org" "Missing bindings")
           "* TODO Binding for %?")
          ))

  ;; Set up custom agenda
  (defun eh/org-skip-subtree-if-bury ()
    "If this entry has the BURY keyword, skip it and its children"
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-get-todo-state) "BURY")
          subtree-end
        nil)))
  (setq org-agenda-custom-commands
        '(("w" "Agenda and work-related tasks"
           ((agenda "Calendar" ((org-agenda-span 1))
                    ((org-agenda-overriding-header "Today")
                     (org-agenda-use-time-grid nil)))
            (todo "NEXT|HALT" ((org-agenda-overriding-header "Look here first")))
            (todo ""
                  ((org-agenda-overriding-header "Get things done")
                   (org-agenda-sorting-strategy '(priority-down))
                   (org-agenda-todo-ignore-with-date t)
                   (org-agenda-skip-function
                    '(or
                      (eh/org-skip-subtree-if-bury)
                      (org-agenda-skip-entry-if 'todo '("NEXT" "READ" "BURY" "GOAL"))
                      ))
                   ))
            (todo "READ" ((org-agenda-overriding-header "Do some reading")))
            (todo "BURY" ((org-agenda-overriding-header "Burried tasks"))))
           ((org-agenda-files (file-expand-wildcards "~/Org/dox-*.org"))
            (org-agenda-tag-filter-preset '("-meta"))
            ;; (org-agenda-compact-blocks t)
            (org-agenda-prefix-format "  %?s"))
           )))

  ;; Each function will be called with no arguments.  The function
  ;; must check if the context is appropriate for it to act.  If yes,
  ;; it should do its thing and then return a non-nil value.  If the
  ;; context is wrong, just do nothing and return nil.
  (defun eh/hook-edit-src-block ()
    (cond ((org-in-src-block-p) (org-edit-src-code))))
  :general
  (:keymap 'org-src-mode-map "C-c C-c" #'org-edit-src-exit)
  :hook
  (org-mode . (lambda()
                (org-indent-mode t)
                (visual-line-mode t)
                ;; (mixed-pitch-mode t)
                ))
  (after-enable-theme . eh/org-update-theme)
  (org-ctrl-c-ctrl-c . eh/hook-edit-src-block)
  ;; (modus-themes-after-load-theme . eh/org-update-modus-theme)
  )
#+end_src
** Making org prettier :org_superstar:
#+begin_src elisp
(use-package org-superstar 
  :config
  (setq org-superstar-cycle-headline-bullets nil
        org-superstar-special-todo-items t
        org-superstar-leading-fallback "·"
        org-superstar-leading-bullet "·"
        org-superstar-remove-leading-stars nil
        ;; org-superstar-headline-bullets-list '("◆" "•")
        org-superstar-headline-bullets-list '("♦" "•")
        org-superstar-prettify-item-bullets nil
        )
  (defun eh/org-superstar-update-theme ()
    (set-face-attribute 'org-superstar-header-bullet nil :weight (face-attribute 'default :weight) :font (face-attribute 'fixed-pitch :font))
    (set-face-attribute 'org-superstar-leading nil :foreground (face-attribute 'org-hide :foreground))
    )
  ;; :init
  (eh/org-superstar-update-theme)
  :hook 
  (org-mode . org-superstar-mode)
  (after-enable-theme . eh/org-superstar-update-theme)
  )
#+end_src
** Making org more powerful
*** For retrieving information :org_super_agenda:
The agenda is a big part of the power of org.
#+begin_src elisp
(use-package org-super-agenda)
#+end_src

Here's some fiddling trying to get a nice agenda going:
#+begin_src elisp :tangle no
(let ((org-super-agenda-groups
       '(
         (:discard (:tag "meta"))
         (:name "Today" ; the name of the section
                ;; :time-grid t ; items that go on the time grid
                :deadline (past today)
                :scheduled (past today)
                :priority "A") ; high priority items
         (:name "Follow Up"
                :todo ("BLOCK" "BLOK" "QSTN")) ; wait? hold?
         )))
  (org-agenda nil "t"))
#+end_src
* Language support
** Misc small packages :fish:haml:slim:
#+begin_src elisp
(use-package fish-mode)
(use-package haml-mode)
(use-package slim-mode)
(use-package sass-mode)
#+end_src
** Writing in Markdown :markdown:
As much as I love org, sometimes I do still have to deal with Markdown. And it's usually github-flavored, so we'll need a package for that.
#+begin_src elisp
(use-package markdown-mode
  :mode
  (("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . gfm-mode))
  :hook
  (gfm-mode . visual-line-mode)
  ;; (gfm-mode . mixed-pitch-mode)
  ;; (markdown-mode . mixed-pitch-mode)
  )
#+end_src
** Javascript with Vue :vue:
I think vue-mode gets us most of what we need. It handles markup and JS in the same file, which is the main thing. In some cases, web-mode can be better, since it supports reasonable folding for HTML elements. It's also useful to have for non-vue mixed-language templates.
#+begin_src elisp
(use-package vue-mode)
(use-package web-mode)
(use-package typescript-mode)
#+end_src
* Footnotes

[fn:1] ~org-babel-demarcate-block~
Make sure there's some content (not just whitespace) between the point and the last source block, or weird things happen. In that case, you can also select a region before the command to wrap it in a source block, which seem consistently reliable. The upside of the weirdness is that this same command, inside of a source block, will split it into two separate ones at point.
