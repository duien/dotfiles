#+title: Streamline literate config

* Commentary
** On early initialization
My previous approach auto-tangled this out of the same file as everything else. It's not something that I revist often or have all that much commentary on. I think it's OK to have that outside of the tangled file, because I /think/ that the approach then becomes tangling the config on startup.
** Startup speed and servers
I definitely like keeping a server running. I think I'd like to make it easier to leave the server running without a frame, but maybe there's really not that much need.
I need to revise my ~ec~ fish function into an actual executable so its usable as ~$EDITOR~
I think terminal for things like git commit message? I wonder if you could make it open the magit changes view alongside it in terminal
** Why I'm rewriting this
I've been using my scratch config full-time for a while, and I think I'm ready for a refactor now that I better understand what I do and don't need, and how it will all fit together
** Organization
I've found that I strongly dislike the huge blocks I end up writing for some of the more  complex packages. It puts too many things in one place to really do the literate thing. But I refuse to have individual blocks that aren't a complete sexp.
There are a couple options to deal with this. There's a sort of constant substitution thing, which requires listing out all the sections that will be inserted. What I want is to be able to use something like Rails' ~content-for~ directives. The sections I want correspond to the keywords of the ~use-package~ 
This could probably be done with a macro but that frightens me.
** Notes on key commands
| Key       | Command                       |
| =C-x n=   | prefix for narrowing commands |
| =C-x n s= | narrow to subtree             |
| =C-x n p= | narrow to page                |

If I'm going to use narrowing, I think I want that paging package from Prot
* Bootstrap straight and use-package
#+begin_src elisp
;; Bootstrap straight
(setq straight-use-package-by-default t)
(setq straight-vc-git-default-clone-depth 1)
(setq straight-recipes-gnu-elpa-use-mirror t)
(setq straight-check-for-modifications nil)
(setq use-package-always-defer t)
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
#+end_src

* Built-in options for basic emacs configuration
Introduce myself to Emacs:
#+begin_src elisp
(setq user-full-name "Emily Hyland"
      user-mail-address "hello@duien.com")
#+end_src

Set up some very basic (and mostly self-explanatory) options:
#+begin_src elisp
(setq inhibit-startup-screen t
      sentence-end-double-space nil
      vc-follow-symlinks t
      dired-use-ls-dired nil
      fill-column 80
      tool-bar-mode -1
      toggle-scroll-bar -1
      mouse-wheel-tilt-scroll t
      fill-column 80
      )
#+end_src

Always allow `y' instead of `yes' in all prompts
#+begin_src elisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

Attempt to make indentation do sensible things:
#+begin_src elisp
(setq-default indent-tabs-mode nil) ;; never use tabs to indent
(setq-default tab-width 2)
(setq tab-always-indent t
      require-final-newline t)
#+end_src

** Everything should always be UTF-8
#+begin_src elisp
(set-charset-priority 'unicode)
(setq locale-coding-system 'utf-8
      coding-system-for-read 'utf-8
      coding-system-for-write 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))

(delete-selection-mode t)
#+end_src
** Set up basic minor modes
#+begin_src elisp
(delete-selection-mode t)
(recentf-mode t)
(setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                        ,(expand-file-name "eln-cache/" user-emacs-directory)
                        ,(expand-file-name "etc/" user-emacs-directory)
                        ,(expand-file-name "var/" user-emacs-directory)))
(winner-mode t) ;; undo/redo window layout changes
(show-paren-mode t)
(display-time-mode -1)

#+end_src

** Configure things for mac
Set up what seems to be the least annoying modifier key setup:
#+begin_src elisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
  (setq mac-control-modifier 'control))
#+end_src

** Technical bits
Some inside baseball options I don't really understand:
#+begin_src elisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
;; less noise when compiling elisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
(setq native-comp-async-report-warnings-errors nil)
(setq load-prefer-newer t)

  (setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
  (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
  (setq enable-local-variables :all)     ; fix =defvar= warnings

#+end_src

* Set up typography
Turn on automatic ligatures if the feature is available:
#+begin_src elisp
(when (fboundp 'mac-auto-operator-composition-mode)
  (setq mac-auto-operator-composition-characters "!\"#$%&'()+,-./:;<=>?@[\\]^_`{|}~w")
  (mac-auto-operator-composition-mode))
#+end_src

Or turn it on the hard way:
#+begin_src elisp
(use-package ligature
  :straight
  '(ligature :type git :host github
             :repo "mickeynp/ligature.el")
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"
                                       "[FAIL]" "[BUG]" "[DEBUG]" "[ERR]" "[ERROR]" "[FAIL]" "[FATAL]"
                                       "[FIXME]" "[HACK]" "[INFO]" "[INFO ]" "[KO]" "[MARK]" "[NOTE]"
                                       "[OK]" "[PASS]" "[PASS ]" "[TODO]" "[TRACE]" "[VERBOSE]"
                                       "[WARN]" "[WARN ]" "[WARNING]"
                                       "|\\" "/|")) ;; these are supposed to be for git hist, but require ss13
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+end_src

** With the Recursive font
Set up fixed and variable pitch fonts with very similar character. It's a dynamic font, but unfortunately Emacs doesn't actually know how to handle that. So for now, we use two separate sets of static configs.
#+begin_src elisp
(defun eh/set-recursive-fonts ()
  (set-face-attribute 'default nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Recursive Sans Casual Static"
                      :height 160 :weight 'normal)
  )
#+end_src

** With Pragmata Pro
#+begin_src elisp
(defun eh/set-pragmata-fonts ()
  (set-face-attribute 'default nil
                      :font "PragmataPro Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "PragmataPro Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "PragmataPro Liga"
                      :height 160 :weight 'normal)
  )
#+end_src

** With Plex fonts
#+begin_src elisp
(defun eh/set-plex-fonts ()
  (set-face-attribute 'default nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "iA Writer Quattro S"
                      :height 160 :weight 'normal)
  )
#+end_src

** With Input fonts
#+begin_src elisp
(defun eh/set-input-fonts ()
  (set-face-attribute 'default nil
                      :font "Input Mono"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Input Mono"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Input Sans"
                      :height 160 :weight 'normal)
  )
#+end_src
** With misc fonts

Victor and Galix are a fun combo.
#+begin_src elisp
(defun eh/set-victor-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 140 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 140 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Galix"
                      :height 170 :weight 'normal)
  )
;; (eh/set-victor-fonts)
#+end_src

#+begin_src elisp
(defun eh/set-belinsky-fonts ()
  (set-face-attribute 'default nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  )
;; (eh/set-victor-fonts)
#+end_src



** And finally, enable a font!
#+begin_src elisp
  ;; (eh/set-recursive-fonts)
  (eh/set-pragmata-fonts)
  ;; (eh/set-plex-fonts)
#+end_src

Interestingly, it turns out that ~mixed-pitch-mode~ doesn't deal well with changing fonts after the fact (even after toggling the mode)

But ~variable-pitch-mode~ seems to do just fine with it. I think I switched because of ... some very specific issues. Let's go back to variable for a while?
* Keybindings
** The surprisingly complicated question of =ESC=
I don't want ESC as a modifier. When I was coming from vim/evil it was just too confusing and tripped me up all the time.
Advice would say use ~keyboard-escape-quit~ as the binding here, which is what's originally bound to =ESC-ESC-ESC= but that makes it too easy to end up closing additional windows, which is basically never what I want.It turns out, however, that ~keyboard-quit~ is not what I want either since it doesn't get me out of the minibuffer. UGH.
What I've ended up with is using ~keyboard-escape-quit~ but modifying it so that the function it calls to kill a buffer just beeps instead. I'm not sure if it actually beeps, though. Am I good at ignoring it, have I retrained myself better than expected, or does it just not work?
#+begin_src elisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq-default buffer-quit-function
	            #'(lambda () (beep)))
#+end_src
*** IDEA What if ~buffer-quit-function~ closed non-file-visiting buffers but left open any file-visiting? That might let it get out of help windows but not out of actual buffer layout.

** Use general to set up keybindings in a friendlier way
#+begin_src elisp
(use-package general
  :demand t
  :config
)
#+end_src

* Completion
What does vertico do and what does consult do?
** Set up consult first
#+begin_src elisp
  (use-package consult
    :init
    ;(setq consult-project-root-function #'projectile-project-root)
    :general
    ("C-x b" 'consult-buffer)
    ("<help> a" 'consult-apropros))
#+end_src

It still only operates in the single line, but it has the preview stuff
** Set up vertico
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode)
    )
#+end_src

Now it actually shows up as a multi-line menu
** Use orderless matching
#+begin_src emacs-lisp
(use-package orderless
  :config
  (defun flex-if-twiddle (pattern _index _total)
    (when (string-suffix-p "~" pattern)
      `(orderless-flex . ,(substring pattern 0 -1))))

  (defun without-if-bang (pattern _index _total)
    (cond
     ((equal "!" pattern)
      '(orderless-literal . ""))
     ((string-prefix-p "!" pattern)
      `(orderless-without-literal . ,(substring pattern 1)))))
  :init
  (setq orderless-matching-styles '(orderless-regexp)
        orderless-style-dispatchers '(without-if-bang flex-if-twiddle))
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Show marginalia when completing
#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode))
#+end_src

* Color Theming
** Set up a hook that's  run after loading a theme
Any theme customization that's done with ~set-face-attribute~ gets lost whenever we switch themes.  Usually you'd solve that with customize, but I kind of hate it. So, instead, we create our own hook taht's run on theme change to set those sorts of things.
#+begin_src elisp
(defvar after-enable-theme-hook nil
   "Normal hook run after enabling a theme.")

(defun run-after-enable-theme-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'after-enable-theme-hook))

(advice-add 'enable-theme :after #'run-after-enable-theme-hook)
#+end_src

** Set up some color themes
#+begin_src elisp
(use-package iodine-theme)
(use-package poet-theme
  :config
  (setq poet-theme-variable-headers nil
        poet-theme-variable-pitch-multiplier 1))
(use-package spacemacs-theme
  :custom
  (spacemacs-theme-comment-bg nil)
  (spacemacs-theme-comment-italic t)
  (spacemacs-theme-org-height nil))
(use-package solo-jazz-theme)
(use-package flucui-themes)
(use-package doom-themes
  :config
  (setq doom-earl-grey-brighter-modeline t))
#+end_src

And finally, actually load a theme:
#+begin_src elisp
(load-theme 'doom-earl-grey t)
#+end_src
** View named colors
#+begin_src elisp
(use-package rainbow-mode)
#+end_src
* Interface
** Use mixed pitch fonts
#+begin_src elisp
(use-package mixed-pitch
  :ensure t)
#+end_src
** Show horizontal rules instead of =^L= 
#+begin_src elisp
(use-package form-feed
  :init
  (form-feed-mode t))
#+end_src
-
** Tab bar with centaur-tabs
#+begin_src elisp
(use-package centaur-tabs
  :init
  (centaur-tabs-mode t))
#+end_src

** A better mode-line
#+begin_src elisp
  ;; (use-package mood-line
  ;;   :init
  ;;   (mood-line-mode 1))
  ;; (use-package moody
  ;;   :config
  ;;   (moody-replace-mode-line-buffer-identification -1)
  ;;   (moody-replace-vc-mode -1))
#+end_src

Use minions to hide all the minor mode indicators in a menu
#+begin_src elisp
(use-package minions
  :config
  (setq minions-mode-line-lighter "≡")
  :init (minions-mode 1))
#+end_src
** A dashboard
#+begin_src elisp
(use-package dashboard
  :ensure t
  :config
  (setq dashboard-projects-backend 'projectile
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-set-init-info t
        )
  (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (projects . 5)
                        (agenda . 5)
                        ))
  ;; (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  :init
  (dashboard-setup-startup-hook))
#+end_src
** A menu of keybindings when you pause
#+begin_src elisp
(use-package which-key
  :config
  ;; this is the default
  (which-key-setup-side-window-bottom)
  :init
  (which-key-mode))
#+end_src
** Make help more helpful
#+begin_src elisp
(use-package helpful
  :bind
  ("C-h f" . helpful-callable)
  ("C-h v" . helpful-variable)
  ("C-h k" . helpful-key)
  ("C-h C" . helpful-command) ;; only interactive functions
  ;; this is overwritten by set-deadline in org
  ("C-c C-d" . helpful-at-point)
  )
#+end_src

* Set up org-mode

** Prepare for org configuration

Define custom faces for all of our keywords. This allows redone styles to be loaded without reload org-mode
#+begin_src elisp
(defun eh/define-org-faces ()
  
  ;; Completed states
  (defface eh/org-keyword-done '((t :inherit org-done))
    "Face used for the DONE keyword in Org")
  (defface eh/org-keyword-kill '((t :inherit org-done))
    "Face used for the KILL keyword in Org")
  (defface eh/org-keyword-answer '((t :inherit org-done))
    "Face used for the ANSR keywork in Org")
  (defface eh/org-keyword-ok '((t :inherit org-done))
    "Face used for the OK keyword in Org")
  (defface eh/org-keyword-yes '((t :inherit eh/org-keyword-done))
    "Face used for the YES keyword in Org")
  (defface eh/org-keyword-no '((t :inherit eh/org-keyword-kill))
    "Face used for the NO keyword in Org")

  ;; Incomplete states
  (defface eh/org-keyword-wait '((t :inherit org-done))
    "Face used for the WAIT keyword in Org")
  (defface eh/org-keyword-flag '((t :inherit org-todo))
    "Face used for the FLAG keyword in Org")
  (defface eh/org-keyword-todo '((t :inherit org-todo))
    "Face used for the TODO keyword in Org")
  (defface eh/org-keyword-block '((t :inherit org-todo))
    "Face used for the BLOK keyword in Org")
  (defface eh/org-keyword-hold '((t :inherit org-todo))
    "Face used for the HOLD keyword in Org")
  (defface eh/org-keyword-question '((t :inherit org-todo))
    "Face used for the QSTN keyword in Org")
  (defface eh/org-keyword-idea '((t :inherit org-todo))
    "Face used for the IDEA keyword in Org")
  (defface eh/org-keyword-yak '((t :inherit org-todo))
    "Face used for the YAK keyword in Org")
  )
#+end_src

Set up some basic org styling that we'll run whenever we change themes:
#+begin_src elisp
  (defun eh/org-update-theme ()
    (set-face-attribute 'org-todo nil
                        :inherit 'fixed-pitch
                        :weight (face-attribute 'bold :weight))
    (set-face-attribute 'org-done nil
                        :inherit 'fixed-pitch
                        :weight (face-attribute 'default :weight))
    (set-face-attribute 'org-headline-todo nil
                        :foreground (face-attribute 'default :foreground)
                        :weight 'normal
                        :inherit nil)
    (set-face-attribute 'org-headline-done nil
                        :inherit '(font-lock-comment-face default))
    (set-face-attribute 'org-hide nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

    ;; Now set up theme-specific things?
    (message "Enabled themes: %s" custom-enabled-themes)
    (message "Should be: %s" (car custom-enabled-themes))
    (when (eq (car custom-enabled-themes) 'doom-isohedron)
      ;; some todo faces
      (set-face-attribute 'org-todo nil
                          :foreground (doom-color 'bg)
                          :background (doom-color 'fw-base3))
      (set-face-attribute 'eh/org-keyword-todo nil
                          :background (doom-color 'fw-green))
      (set-face-attribute 'eh/org-keyword-flag nil
                          :background (doom-color 'fw-orange))
      (set-face-attribute 'eh/org-keyword-block nil
                          :background (doom-color 'fw-red))
      (set-face-attribute 'eh/org-keyword-question nil
                          :background (doom-color 'fw-blue))
      (set-face-attribute 'eh/org-keyword-idea nil
                          :background (doom-color 'fw-teal))
      (set-face-attribute 'eh/org-keyword-yak nil
                          :background (doom-color 'fw-purple))
      (set-face-attribute 'eh/org-keyword-hold nil
                          :foreground (doom-color 'fw-yellow-text)
                          :background (doom-color 'fw-yellow))
      (set-face-attribute 'eh/org-keyword-wait nil
                          :foreground (doom-color 'fg-alt)
                          :background (doom-color 'fw-base5))
      (set-face-attribute 'eh/org-keyword-answer nil
                          :foreground (doom-color 'fw-blue))
      (set-face-attribute 'eh/org-keyword-yes nil
                          :foreground (doom-color 'fw-green))
      (set-face-attribute 'eh/org-keyword-no nil
                          :foreground (doom-color 'fw-red))
      (set-face-attribute 'eh/org-keyword-ok nil
                          :foreground (doom-color 'fg-alt))
      (set-face-attribute 'eh/org-keyword-done nil
                          :foreground (doom-color 'fg-alt))
      (set-face-attribute 'eh/org-keyword-kill nil
                          :foreground (doom-color 'fg-alt))
      )
    )

  ;; (eh/org-update-theme)
#+end_src

** Basic configuration
#+begin_src elisp
  (use-package org
    :config
    (eh/define-org-faces)
    (eh/org-update-theme)
    ;; :init
    (setq org-directory "~/Org/"
          org-agenda-files '("~/Org/")
          org-refile-targets '((org-agenda-files . (:maxlevel . 5)))
          org-log-done t
          org-log-into-drawer t
          org-insert-heading-respect-content t
          org-cycle-separator-lines 2 ;; 2 blank lines to keep when collapsed
          org-indent-mode-turns-on-hiding-stars nil
          org-hide-leading-stars nil
          org-ellipsis " …"
          org-fontify-whole-block-delimiter-line nil
          org-fontify-whole-heading-line t
          org-fontify-todo-headline t
          org-fontify-done-headline t
          org-src-preserve-indentation t
          org-startup-truncated t)
    (setq org-todo-keywords
          '((sequence "WAIT(w)" "FLAG(f)" "TODO(t)" "BLOK(b)" "HOLD(h)" "|" "DONE(d!)" "KILL(k@)")
            (sequence "QSTN(q)" "|" "  OK(o)" " YES(y)" "  NO(n)" "ANSR(a@)")
            (type "IDEA(I)" " YAK(Y)" "|")
            ))

    (setq org-todo-keyword-faces
          `(("TODO" . eh/org-keyword-todo)
            ("FLAG" . eh/org-keyword-flag)
            ("DONE" . eh/org-keyword-done)
            ("HOLD" . eh/org-keyword-hold)
            ("BLOK" . eh/org-keyword-block)
            ("WAIT" . eh/org-keyword-wait)
            ("KILL" . eh/org-keyword-kill)
            ("QSTN" . eh/org-keyword-question)
            ("ANSR" . eh/org-keyword-answer)
            ("  OK" . eh/org-keyword-ok)
            (" YES" . eh/org-keyword-yes)
            ("  NO" . eh/org-keyword-no)
            ("IDEA" . eh/org-keyword-idea)
            (" YAK" . eh/org-keyword-yak)
            ))
    :hook
    (org-mode . (lambda()
                  (org-indent-mode t)
                  (visual-line-mode t)
                  (variable-pitch-mode t)
                  ;; (mixed-pitch-mode t)
                  ))
    (after-enable-theme . eh/org-update-theme)
    )
  ;; (eh/org-update-theme)
#+end_src
** Making org prettier
#+begin_src elisp
(use-package org-superstar 
  :init
  (setq org-superstar-cycle-headline-bullets nil
        org-superstar-special-todo-items t
        org-superstar-leading-fallback "·"
        org-superstar-leading-bullet "·"
        org-superstar-remove-leading-stars nil
        org-superstar-headline-bullets-list '("◆" "•"))
  (setq org-superstar-todo-bullet-alist
        '(("TODO"     . ?›)
          ("FLAG"     . ?»)
          ("DONE"     . ?✓)
          ("WAIT"     . ?≈)
          ("BLOK"     . ?◊)
          ("HOLD"     . ?~)
          ("KILL"     . ?×)
          ("QSTN"     . ??)
          ("ANSR"     . ?•)
          ("  OK"     . ?·)
          (" YES"     . ?·)
          ("  NO"     . ?·)
          ("IDEA"     . ?•)
          (" YAK"     . ?∞)
          )
        org-superstar-prettify-item-bullets nil
        )
  (defun eh/org-superstar-update-theme ()
    (set-face-attribute 'org-superstar-header-bullet nil :weight (face-attribute 'default :weight) :font (face-attribute 'fixed-pitch :font))
    (set-face-attribute 'org-superstar-leading nil :foreground (face-attribute 'font-lock-comment-face :foreground))
    )
  :config
  (eh/org-superstar-update-theme)
  :hook 
  (org-mode . org-superstar-mode)
  (after-enable-theme . eh/org-superstar-update-theme)
  )
#+end_src
** Testing org styling
*** TODO A task
*** DONE This one is doneso
*** FLAG A flag
*** HOLD On hold
*** BLOK Blocked
*** WAIT Waiting
*** KILL Not doable
*** QSTN A question
*** ANSR An answer
***   OK Is fine
***  YES is affirmative
***   NO Is negative
*** IDEA Is a maybe
***  YAK Is a time-sink

* Simple utilities for better editing
Crux has lots of handy utility functions. These are a few of the best:
#+begin_src elisp
(use-package crux
  :bind 
  ("C-o" . crux-smart-open-line)
  ("M-o" . crux-smart-open-line-above)
  ("C-k" . crux-smart-kill-line)
  )
#+end_src

Expanding the region incrementally is incredibly helpful:
#+begin_src elisp
(use-package expand-region
  :bind
  ("C-=" . er/expand-region))
#+end_src

Pulse the cursor line when moving around
#+begin_src elisp
(use-package pulsar
  :straight
  '(pulsar :type git :host gitlab :repo "protesilaos/pulsar")
  :init
  (pulsar-setup))
#+end_src

Move forward and backward through pages when the buffer is narrowed.
#+begin_src elisp
(use-package logos
  :config
  (setq logos-outlines-are-pages t)
  :general
  ([remap narrow-to-region] 'logos-narrow-dwim)
  ([remap forward-page] 'logos-forward-page-dwim)
  ([remap backward-page] 'logos-backward-page-dwim))
  
(use-package olivetti
  :config
  (setq olivetti-style fancy))
#+end_src

Manage whitespace automatically
#+begin_src elisp
(use-package ws-butler
  :hook
  (prog-mode . ws-butler-mode))
#+end_src
** Do better things with line wrapping
#+begin_src elisp
(use-package visual-fill-column
  :config
  ;; (setq-default visual-fill-column-extra-text-width '(2 . 2))
  (setq visual-fill-column-enable-sensible-window-split t)
  :hook
  (visual-line-mode . visual-fill-column-mode))
(use-package adaptive-wrap)
#+end_src
