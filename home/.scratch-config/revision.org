#+title: Streamline literate config
#+startup: show2levels
#+ARCHIVE: ~/Org/archive.org::* From %s

* Commentary
:PROPERTIES:
:visibility: folded
:END:
** On early initialization
My previous approach auto-tangled this out of the same file as everything else. It's not something that I revist often or have all that much commentary on. I think it's OK to have that outside of the tangled file, because I /think/ that the approach then becomes tangling the config on startup.
** Startup speed and servers
I definitely like keeping a server running. I think I'd like to make it easier to leave the server running without a frame, but maybe there's really not that much need.
I think terminal for things like git commit message? I wonder if you could make it open the magit changes view alongside it in terminal
** Why I'm rewriting this
I've been using my scratch config full-time for a while, and I think I'm ready for a refactor now that I better understand what I do and don't need, and how it will all fit together
** Organization
I've found that I strongly dislike the huge blocks I end up writing for some of the more  complex packages. It puts too many things in one place to really do the literate thing. But I refuse to have individual blocks that aren't a complete sexp.
There are a couple options to deal with this. There's a sort of constant substitution thing, which requires listing out all the sections that will be inserted. What I want is to be able to use something like Rails' ~content-for~ directives. The sections I want correspond to the keywords of the ~use-package~ 
This could probably be done with a macro but that frightens me.
* Notes on key commands
:PROPERTIES:
:visibility: all
:END:
Not any particularly significance or sort order, just things I'm trying to learn:
| Key               | Command                            |
|-------------------+------------------------------------|
| =C-x n=           | prefix for narrowing commands      |
| =C-x n s=         | narrow to subtree                  |
| =C-x n p=         | narrow to page                     |
| =C-c C-v d=       | insert babel source block[fn:1]    |
| =M-m=             | back-to-indentation                |
| =C-c C-x C-a=     | archive current subtree            |
| =C-u C-c C-x C-a= | ask about archiving children       |
| =C-c C-x b=       | indirect buffer of current subtree |
|                   |                                    |

* Bootstrap straight and use-package
This is now done directly in =init.el= so that we pick up the straight-managed version of org instead of the built in one. There's still probably some issues with getting configuration to all happen at the right time, though...
* Built-in options for basic emacs configuration
Introduce myself to Emacs:
#+begin_src elisp
(setq user-full-name "Emily Hyland"
      user-mail-address "hello@duien.com")
#+end_src

Set up some very basic (and mostly self-explanatory) options:
#+begin_src elisp
(setq inhibit-startup-screen t
      sentence-end-double-space nil
      vc-follow-symlinks t
      dired-use-ls-dired nil
      fill-column 80
      tool-bar-mode -1
      toggle-scroll-bar -1
      mouse-wheel-tilt-scroll t
      custom-safe-themes t
      )
#+end_src

Always allow `y' instead of `yes' in all prompts
#+begin_src elisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

If you type over a selection, delete it first
#+begin_src elisp
(delete-selection-mode t)
#+end_src
** Everything should always be UTF-8
#+begin_src elisp
(set-charset-priority 'unicode)
(setq locale-coding-system 'utf-8
      coding-system-for-read 'utf-8
      coding-system-for-write 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src
** Set up basic minor modes
#+begin_src elisp
(delete-selection-mode t)
(recentf-mode t)
(setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                        ,(expand-file-name "eln-cache/" user-emacs-directory)
                        ,(expand-file-name "etc/" user-emacs-directory)
                        ,(expand-file-name "var/" user-emacs-directory)))
(winner-mode t) ;; undo/redo window layout changes
(show-paren-mode t)
(display-time-mode -1)
#+end_src
** Set up reasonable indentation defaults
Attempt to make indentation do sensible things:
#+begin_src elisp
(setq-default indent-tabs-mode nil) ;; never use tabs to indent
(setq-default tab-width 2)
(setq js-indent-level 2)
(setq tab-always-indent t
      require-final-newline t)
#+end_src

And let other people decide per-project values:
#+begin_src elisp
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src
** Prevent autosave and backup files littered everywhere
#+begin_src elisp
(setq backup-directory-alist
      '((".*" . "~/.emacs-backups")))
(setq auto-save-file-name-transforms
      '((".*" "~/.emacs-backups" t)))
#+end_src
** Configure things for mac
Set up what seems to be the least annoying modifier key setup:
#+begin_src elisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
  (setq mac-control-modifier 'control))
#+end_src
** Technical bits
Some inside baseball options I don't really understand:
#+begin_src elisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
;; less noise when compiling elisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
(setq native-comp-async-report-warnings-errors nil)
(setq load-prefer-newer t)

  (setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
  (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
  (setq enable-local-variables :all)     ; fix =defvar= warnings

#+end_src
* How it looks
** Set up typography
*** With the Recursive font
Set up fixed and variable pitch fonts with very similar character. It's a dynamic font, but unfortunately Emacs doesn't actually know how to handle that. So for now, we use two separate sets of static configs.
#+begin_src elisp
(defun eh/set-recursive-fonts ()
  (set-face-attribute 'default nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Rec Mono Duotone"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Recursive Sans Casual Static"
                      :height 160 :weight 'normal)
  )
#+end_src

*** With Pragmata Pro
#+begin_src elisp
(defun eh/set-pragmata-fonts ()
  (set-face-attribute 'default nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "PragmataPro Mono Liga"
                      :height 160 :weight 'normal)
  )
#+end_src

**** All the extra ligatures and things
For PragmataPro, there are so many additional ligatures and things that are beyond what's needed for other fonts. The normal ligature configuration will not be sufficient, so we'd need to add a couple things to really get it working

[[https://github.com/lumiknit/emacs-pragmatapro-ligatures][emacs-pragmatapro-ligatures]] package on Github should set everything up for the most recent version.

However, MyFonts is stupid, and so I'm missing one style (PragmataPro Liga Regular) in the lastest version. I can use the mono version, but it's missing some of the more complex things. It _might_ be possible to set up a fallback font?

[[https://stackoverflow.com/questions/6083496/how-do-you-specify-a-fallback-font-in-emacs][This StackOverflow post]] has some information about how to do that, but not sure if it will really work for this weird situation.

*** With Plex fonts
#+begin_src elisp
(defun eh/set-plex-fonts ()
  (set-face-attribute 'default nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "IBM Plex Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "iA Writer Quattro V"
                      :height 160 :weight 'semilight)
  )
#+end_src

*** With Input fonts
#+begin_src elisp
(defun eh/set-input-fonts ()
  (set-face-attribute 'default nil
                      :family "Input Mono Condensed"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :family "Input Mono Condensed"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :family "Input Sans Condensed"
                      :height 160 :weight 'normal)
  )
#+end_src
*** With Sudo fonts
#+begin_src elisp
(defun eh/set-sudo-fonts ()
  (set-face-attribute 'default nil
		      :font "Sudo"
		      :height 200 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
		      :font "Sudo"
		      :height 200 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
		      :font "Sudo UI"
		      :height 200 :weight 'normal))
#+end_src

*** With misc fonts

Victor and Galix are a fun combo.
#+begin_src elisp
(defun eh/set-victor-galix-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Galix"
                      :height 170 :weight 'normal)
  )
#+end_src

#+begin_src elisp
(defun eh/set-victor-fonts ()
  (set-face-attribute 'default nil
                      :font "Victor Mono"
                      :height 170 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Victor Mono"
                      :height 170 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Overpass"
                      :height 170 :weight 'semilight)
  )
#+end_src

#+begin_src elisp
(defun eh/set-belinsky-fonts ()
  (set-face-attribute 'default nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "Belinsky Text"
                      :height 160 :weight 'normal)
  )
#+end_src

#+begin_src elisp
(defun eh/set-monolisa-fonts ()
  (set-face-attribute 'default nil
                      :font "MonoLisa"
                      :height 160 :weight 'normal)
  (set-face-attribute 'fixed-pitch nil
                      :font "MonoLisa"
                      :height 160 :weight 'normal)
  (set-face-attribute 'variable-pitch nil
                      :font "MonoLisa"
                      :height 160 :weight 'normal)
  )
#+end_src

#+begin_src elisp
(defun eh/set-cascadia-fonts ()
  (set-face-attribute 'default nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Cascadia Code"
                      :height 160 :weight 'light)
  )
#+end_src

#+begin_src elisp
(defun eh/set-roboto-fonts ()
  (set-face-attribute 'default nil
                      :font "Roboto Mono"
                      :height 160 :weight 'light)
  (set-face-attribute 'fixed-pitch nil
                      :font "Roboto Mono"
                      :height 160 :weight 'light)
  (set-face-attribute 'variable-pitch nil
                      :font "Roboto Mono"
                      :height 160 :weight 'light)
  )
#+end_src
*** With Apple fonts
#+begin_src elisp
(defun eh/set-apple-fonts ()
  (set-face-attribute 'default nil
                      :font "SF Mono"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'fixed-pitch nil
                      :font "SF Mono"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'variable-pitch nil
                      :font "SF Pro Text"
                      :height 160 :weight 'semilight)
  (set-face-attribute 'org-document-title nil
                      :font "New York Extra Large"
                      :height 2.0 :weight 'bold)
 
  (set-face-attribute 'org-level-1 nil
                      :family "New York Medium"
                      :weight 'semibold :height 1.4)
  ;; Causing issues with line-height on TODO items
  ;; (set-face-attribute 'org-level-2 nil
  ;;                     :family "New York Medium"
  ;;                     :weight 'semibold
  ;;                     :height 1.2)
  (set-face-attribute 'org-ellipsis nil
                    :font "SF Mono"
                    :inherit '(shadow default))
  )
#+end_src

*** And finally, enable a font!
#+begin_src elisp
;; (eh/set-recursive-fonts)
;; (eh/set-pragmata-fonts)
;; (eh/set-plex-fonts)
;; (eh/set-victor-fonts)
;; (eh/set-input-fonts)
;; (eh/set-sudo-fonts)
;; (eh/set-apple-fonts)
(add-hook 'after-enable-theme-hook #'eh/set-apple-fonts)
#+end_src

Interestingly, it turns out that ~mixed-pitch-mode~ doesn't deal well with changing fonts after the fact (even after toggling the mode)

But ~variable-pitch-mode~ seems to do just fine with it. I think I switched because of ... some very specific issues. Let's go back to variable for a while?

I've left mixed installed, but [[*Basic configuration][the org-mode hook configuration]] is what controls what we actually use.
*** Set up ligatures in various ways
Turn on automatic ligatures if the feature is available:
#+begin_src elisp
(when (fboundp 'mac-auto-operator-composition-mode)
  (setq mac-auto-operator-composition-characters "!\"#$%&'()+,-./:;<=>?@[\\]^_`{|}~w")
  (mac-auto-operator-composition-mode))
#+end_src

Or turn it on the hard way:
#+begin_src elisp
(use-package ligature
  :straight
  '(ligature :type git :host github
             :repo "mickeynp/ligature.el")
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 't '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"
                                       "[FAIL]" "[BUG]" "[DEBUG]" "[ERR]" "[ERROR]" "[FAIL]" "[FATAL]"
                                       "[FIXME]" "[HACK]" "[INFO]" "[INFO ]" "[KO]" "[MARK]" "[NOTE]"
                                       "[OK]" "[PASS]" "[PASS ]" "[TODO]" "[TRACE]" "[VERBOSE]"
                                       "[WARN]" "[WARN ]" "[WARNING]"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+end_src
** Color Theming
*** Set up a hook that's  run after loading a theme
Any theme customization that's done with ~set-face-attribute~ gets lost whenever we switch themes.  Usually you'd solve that with customize, but I kind of hate it. So, instead, we create our own hook taht's run on theme change to set those sorts of things.
#+begin_src elisp
(defvar after-enable-theme-hook nil
   "Normal hook run after enabling a theme.")

(defun run-after-enable-theme-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'after-enable-theme-hook))

(advice-add 'enable-theme :after #'run-after-enable-theme-hook)
#+end_src
*** Set up Modus
First, define a few functions that are useful to our use of Modus:
#+begin_src elisp
(defun eh/modus-customize ()
  (set-face-attribute 'font-lock-string-face nil :slant 'italic)
  ;; (set-face-attribute 'org-document-title nil :height 1.5)
  )

(defun eh/load-theme (appearance)
  "Load theme, taking current system APPEARANCE into consideration."
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (modus-themes-load-operandi))
    ('dark (modus-themes-load-vivendi))))

(defun eh/org-update-modus-theme ()
    (set-face-attribute 'eh/org-keyword-todo nil
                        :inherit '(modus-themes-refine-green org-todo))
    (set-face-attribute 'eh/org-keyword-next nil
                        :inherit '(modus-themes-refine-yellow org-done))
    (set-face-attribute 'eh/org-keyword-halt nil
                        :inherit '(modus-themes-intense-red org-todo))
    (set-face-attribute 'eh/org-keyword-bury nil
                        :inherit '(modus-themes-intense-neutral org-done))
    (set-face-attribute 'eh/org-keyword-question nil
                        :inherit '(modus-themes-refine-blue org-todo))
    (set-face-attribute 'eh/org-keyword-idea nil
                        :inherit '(modus-themes-refine-cyan org-todo))
    (set-face-attribute 'eh/org-keyword-yaks nil
                        :inherit '(modus-themes-refine-magenta org-todo))
    (set-face-attribute 'eh/org-keyword-done nil
                        :inherit '(modus-themes-nuanced-green org-done)
                        :foreground (modus-themes-color 'green-faint))
    (set-face-attribute 'eh/org-keyword-kill nil
                        :inherit '(modus-themes-nuanced-red org-done)
                        :foreground (modus-themes-color 'red-faint))
    (set-face-attribute 'eh/org-keyword-answer nil
                        :inherit '(modus-themes-nuanced-blue org-done)
                        :foreground (modus-themes-color 'blue-faint))
    (set-face-attribute 'eh/org-keyword-meh nil
                        :inherit 'eh/org-keyword-answer
                        :foreground (modus-themes-color 'blue))
    (set-face-attribute 'eh/org-keyword-yes nil
                        :inherit 'eh/org-keyword-done
                        :foreground (modus-themes-color 'green))
    (set-face-attribute 'eh/org-keyword-no nil
                        :inherit 'eh/org-keyword-kill
                        :foreground (modus-themes-color 'red))
    )
#+end_src

#+begin_src elisp
(use-package modus-themes
  :config
  (setq modus-themes-mixed-fonts t
        modus-themes-variable-pitch-ui nil ;; bad w/ nano
        modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-subtle-line-numbers t
        modus-themes-markup '(background intense)
        modus-themes-links '(background)
        modus-themes-fringes nil ;; background of fringe area
        modus-themes-mode-line '(moody accented)
        modus-themes-syntax '(green-strings)
        modus-themes-org-blocks 'gray-background
        modus-themes-completions '((t background intense accented))
        modus-themes-region '(bg-only accented)
        )
  ;; (add-hook 'ns-system-appearance-change-functions #'eh/load-theme)
  :init
  (modus-themes-load-themes)
  :hook
  (modus-themes-after-load-theme . eh/modus-customize)
  (modus-themes-after-load-theme . eh/org-update-modus-theme)
  )
#+end_src
*** Set up some alternate color themes
#+begin_src elisp
(use-package iodine-theme)
(use-package poet-theme
  :config
  (setq poet-theme-variable-headers nil
        poet-theme-variable-pitch-multiplier 1))
(use-package spacemacs-theme
  :custom
  (spacemacs-theme-comment-bg nil)
  (spacemacs-theme-comment-italic t)
  (spacemacs-theme-org-height nil))
(use-package solo-jazz-theme)
(use-package flucui-themes)
(use-package doom-themes
  :config
  (setq doom-isohedron-brighter-modeline t)
  (setq doom-earl-grey-brighter-modeline t))
(use-package nano-theme)
(use-package bespoke-theme
  :straight (:host github :repo "mclear-tools/bespoke-themes" :branch "main"))

(load-theme 'doom-isohedron)
#+end_src
*** View named colors
#+begin_src elisp
(use-package rainbow-mode)
#+end_src
*** Fancy and unnecessary SVG tags
#+begin_src elisp
(use-package svg-lib)
(use-package svg-tag-mode
  :straight (:type git :host github :repo "rougier/svg-tag-mode")
  :config
  (setq svg-tag-tags
      '((":TODO:" . ((lambda (tag) (svg-tag-make "TODO")))))))
#+end_src
** Interface
*** IDEA Make the mark always visible
This is a start. It adds the ability to visualize the mark, but (at least with transient-mark-mode) it only seems to show them when the mark is active.
#+begin_src elisp
(use-package visible-mark
  :config
  (setq visible-mark-max 5)
  :init
  (global-visible-mark-mode 1))
#+end_src
*** TODO Use mixed pitch fonts
#+begin_src elisp
(use-package mixed-pitch
  :ensure t)
#+end_src
This is really determined by which mode we load in org. I'd been using variable-pitch-mode but it's doing something weird with tables (every character I check says it's mono, but the lines don't line up). I think overall mixed-pitch-mode works better, but had some compatibility issues, possibly involving dimmer and/or changing fonts.
**** TODO 
*** Show horizontal rules instead of =^L= 
#+begin_src elisp
(use-package form-feed
  :init
  (form-feed-mode t))
#+end_src
-
*** A better mode-line
#+begin_src elisp
  ;; (use-package mood-line
  ;;   :init
  ;;   (mood-line-mode 1))
  ;; (use-package moody
  ;;   :config
  ;;   (moody-replace-mode-line-buffer-identification -1)
  ;;   (moody-replace-vc-mode -1))

(use-package nano-modeline) ;; (nano-modeline-mode)
(use-package bespoke-modeline
  :straight (bespoke-modeline :type git :host github :repo "mclear-tools/bespoke-modeline")
  :config
  (setq bespoke-modeline-position 'top
        bespoke-modeline-vc-symbol "#"))
#+end_src

Additional bespoke modeline options:
#+begin_example
bespoke-modeline-(gui|tty)-(mod|rw|ro)-symbol
bespoke-modeline-space-(bottom|top)
? bespoke-modeline-user-mode
bespoke-modeline-vc-symbol
bespoke-modeline-visual-bell
face for bespoke-modeline-visual-bell-config
#+end_example

Use minions to hide all the minor mode indicators in a menu
#+begin_src elisp
(use-package minions
  :config
  (setq minions-mode-line-lighter "≡")
  :init (minions-mode 1))
#+end_src
*** A dashboard
#+begin_src elisp
(use-package dashboard
  :ensure t
  :config
  (setq dashboard-projects-backend 'projectile
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-set-init-info t
        )
  (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (projects . 5)
                        (agenda . 5)
                        ))
  ;; (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  :init
  (dashboard-setup-startup-hook))
#+end_src 
*** A menu of keybindings when you pause
#+begin_src elisp
(use-package which-key
  :config
  ;; this is the default
  (which-key-setup-side-window-bottom)
  :init
  (which-key-mode))
#+end_src
*** Make help more helpful
#+begin_src elisp
(use-package helpful
  :bind
  ("C-h f" . helpful-callable)
  ("C-h v" . helpful-variable)
  ("C-h k" . helpful-key)
  ("C-h C" . helpful-command) ;; only interactive functions
  ;; this is overwritten by set-deadline in org
  ("C-c C-d" . helpful-at-point)
  )
#+end_src
*** Selectively dim windows
It's a choice between solaire, which dims non-file-visiting buffers, and dimmer, which dims inactive buffers. Wouldn't rule-based buffer colors be cool?
**** BURY Solaire
**** Dimmer
#+begin_src elisp
(use-package dimmer
  :config
  (setq dimmer-fraction 0.4) ;; this is right for isohedron
  (dimmer-configure-which-key)
  (dimmer-configure-org)
  (dimmer-configure-magit)
  ;; (dimmer-configure-posframe)
  ;; (dimmer-configure-hydra) ;; ??
  (dimmer-mode 1)
  )
#+end_src
*** Show the minibuffer somewhere more visible
#+begin_src elisp
(use-package mini-frame
  :config
  (setq mini-frame-background-color-function
        (lambda ()
          (face-attribute 'mode-line-inactive :background)))
  (setq mini-frame-show-parameters
        '((child-frame-border-width . 1) ;; or maybe 12 matching background
          (no-accept-focus . t) ;; makes initial height work correctly
          (left . 0.5) ;; center horizontally
          (top . 0.25) ;; about a quarter down
          (width . 0.8) ;; narrower than the frame usually
          (min-width . 80) ;; at least 80 chars
          (height . 1)
          (keep-ratio . t) ;; keep proportion as parent resizes
          ))
  (setq mini-frame-resize t)
  :init
  (mini-frame-mode t))
#+end_src

* What it can do
** Keybindings
*** The surprisingly complicated question of =ESC=
I don't want ESC as a modifier. When I was coming from vim/evil it was just too confusing and tripped me up all the time.
Advice would say use ~keyboard-escape-quit~ as the binding here, which is what's originally bound to =ESC-ESC-ESC= but that makes it too easy to end up closing additional windows, which is basically never what I want.It turns out, however, that ~keyboard-quit~ is not what I want either since it doesn't get me out of the minibuffer. UGH.
What I've ended up with is using ~keyboard-escape-quit~ but modifying it so that the function it calls to kill a buffer just beeps instead. I'm not sure if it actually beeps, though. Am I good at ignoring it, have I retrained myself better than expected, or does it just not work?
#+begin_src elisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq-default buffer-quit-function
	            #'(lambda () (beep)))
#+end_src
**** IDEA What if ~buffer-quit-function~ closed non-file-visiting buffers but left open any file-visiting? That might let it get out of help windows but not out of actual buffer layout.
*** Use general to set up keybindings in a friendlier way
#+begin_src elisp
(use-package general
  :demand t
)
;;   ("<help> F" 'describe-face)
#+end_src
** Vertical completion interface
This is what's used when switching buffers, searching for files, refiling to an org headline, all that stuff.
*** Set up consult first
Consult is what sets the contents of those menus. It provides a really nice buffer switch interface, ~consult-buffer~, which includes a variety of sources and the ability to use a single-letter prefix 
#+begin_src elisp
  (use-package consult
    :config
    (setq consult-preview-key (kbd "M=."))
    :init
    ;(setq consult-project-root-function #'projectile-project-root)
    :general
    ("C-x b" 'consult-buffer)
    ("<help> a" 'consult-apropros)
    ("<help> t" 'consult-theme))
#+end_src

It still only operates on the single line, but it provides the nicer menus, and allows previewing the thing to be switched to (buffers, themes, etc).
*** Set up vertico
Vertico is what takes the completion functions from consult and turns them into what we'd normally think of as an autocomplete window. It's a few lines high, shows the input at the top, and provides a list of the possible results. You can move up and down through the list, or continue typing to keep narrowing.
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode))
#+end_src
*** Use orderless matching
Speaking of matching, it's something that apparently I have Opinions about. It's important for the way I use it (and the organization of the projects I'm often navigating) that I can add additional elements to the match out of order. I might start searching for a model, =mod= then =us= for user. Oh, but I need the spec, so =spec=. In a lot of completion setups, I'd have to go back to the beginning of the string to add a filter that's higher up in the file tree. But with orderless, I can add the tokens in whatever order I want!
In order for that not to make the search space too big, I then have to separate the tokens with spaces. It can sometimes be annoying, but it's sometimes actually useful for disambiguation.
#+begin_src emacs-lisp
(use-package orderless
  :config
  (defun flex-if-twiddle (pattern _index _total)
    (when (string-suffix-p "~" pattern)
      `(orderless-flex . ,(substring pattern 0 -1))))

  (defun without-if-bang (pattern _index _total)
    (cond
     ((equal "!" pattern)
      '(orderless-literal . ""))
     ((string-prefix-p "!" pattern)
      `(orderless-without-literal . ,(substring pattern 1)))))
  :init
  (setq orderless-matching-styles '(orderless-regexp)
        orderless-style-dispatchers '(without-if-bang flex-if-twiddle))
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Show marginalia when completing
This adds the additional columns to the completion window. Extra info, and I think it fixes an alignment issue with variable pitch fonts.
#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode))
#+end_src
** Scratch buffer is magic
I use the scratch buffer a lot, and it's nice to have the things there stick around unless I delete them on purpose. It's a good place to stash log output, temporary shell command editing, things like that, but sometimes I need to restart my editor while still in the middle of those tasks.
#+begin_src elisp
(use-package persistent-scratch
  :demand t
  :init
  (persistent-scratch-setup-default)
  (persistent-scratch-mode 1))
#+end_src
** Version control
Set up the best git interface:
#+begin_src elisp
(use-package magit)
#+end_src

See which lines have been modified in the gutter
#+begin_src elisp
(use-package diff-hl
  :hook
  (magit-pre-refresh . diff-hl-magit-pre-refresh)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :init
  (global-diff-hl-mode 1))
#+end_src
** Use projects for organization
#+begin_src elisp
(use-package projectile
  :config
  (setq projectile-project-search-path
	'(("~/Code" . 3)
	  ("~/.homesick/repos" . 1)))
  (projectile-add-known-project "~/Org")
  (projectile-add-known-project "~/Notes")
  :general
  ("C-x p" '(:keymap projectile-command-map :package projectile))
  :init
  (projectile-mode 1))
#+end_src
** A shell in the editor
#+begin_src elisp
(use-package vterm)
#+end_src
** Organize and focus on buffer groups
#+begin_src elisp
(use-package bufler
  :init
  (bufler-mode))
#+end_src
* Simple utilities for better editing
Crux has lots of handy utility functions. These are a few of the best:
#+begin_src elisp
(use-package crux
  :bind 
  ("C-o" . crux-smart-open-line)
  ("M-o" . crux-smart-open-line-above)
  ("C-k" . crux-smart-kill-line)
  )
#+end_src

Expanding the region incrementally is incredibly helpful:
#+begin_src elisp
(use-package expand-region
  :bind
  ("C-=" . er/expand-region))
#+end_src

Allow highlighting color-like things in their colors. This isn't very smart about things, and tends to highlight named colors in an annoying number of places, but when it's useful it's really useful.
#+begin_src elisp
(use-package rainbow-mode)
#+end_src

Move forward and backward through pages when the buffer is narrowed:
#+begin_src elisp
(use-package logos
  :config
  (setq logos-outlines-are-pages t)
  :general
  ([remap narrow-to-region] 'logos-narrow-dwim)
  ([remap forward-page] 'logos-forward-page-dwim)
  ([remap backward-page] 'logos-backward-page-dwim))
  
(use-package olivetti
  :config
  (setq olivetti-style fancy))
#+end_src

Manage whitespace automatically:
#+begin_src elisp
(use-package ws-butler
  :hook
  (prog-mode . ws-butler-mode))
#+end_src
** Do better things with line wrapping
#+begin_src elisp
(use-package visual-fill-column
  :config
  ;; (setq-default visual-fill-column-extra-text-width '(2 . 2))
  (setq visual-fill-column-enable-sensible-window-split t)
  ;; :hook
  ;; (visual-line-mode . visual-fill-column-mode)
  )
(use-package adaptive-wrap)
#+end_src
** TODO Parentheses matching and surround
** Toggle between vertical and horizontal split windows
#+begin_src elisp
(defun eh/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+end_src
** Pulse the line after movement
#+begin_src elisp
(use-package pulsar
  :config
  (setq pulsar-pulse t ;; leave the highlight in place until another command
        pulsar-delay 0.5 ;; how long each step lasts
        pulsar-iterations 1 ;; how many steps for color
        pulsar-face 'pulsar-yellow
        )
  :general
  ;; Bind pulsar-hightlight-dwim
  ;; Bind pulsar-pulse-line
  :init
  (pulsar-global-mode 1)
  ;; pulsar-face
  )
#+end_src
* Set up org-mode
** Prepare for org configuration

Define custom faces for all of our keywords. This allows redone styles to be loaded without reload org-mode
#+begin_src elisp
    (cl-defun eh/org-register-keyword (&key keywords face symbol)
      (dolist (key keywords)
        (add-to-list 'org-todo-keyword-faces `(,key . ,face))
        (add-to-list 'org-superstar-todo-bullet-alist `(,key . ,symbol))
      ))
    (defun eh/define-org-keywords ()
      ;; Register all variations of keywords with faces and symbols
      ;; Only the ones included in `org-todo-keywords' will be
      ;; activated by default, but the others will still be styled
      ;; if activated by buffer properties

      ;; First, clear out (and register) the two lists we're building up
      (setq org-todo-keyword-faces '()
            org-superstar-todo-bullet-alist '())

      (eh/org-register-keyword
       :keywords '("DONE")
       :symbol ?✓
       :face (defface eh/org-keyword-done '((t :inherit org-done))
               "Face used for the DONE keyword in Org"))
      (eh/org-register-keyword
       :keywords '("KILL" "CANCEL")
       :symbol ?×
       :face (defface eh/org-keyword-kill '((t :inherit org-done))
               "Face used for the KILL keyword in Org"))
      (eh/org-register-keyword
       :keywords '("ANSWER" "ANSR")
       :symbol ?·
       :face (defface eh/org-keyword-answer '((t :inherit org-done))
               "Face used for the ANSR keywork in Org"))
      (eh/org-register-keyword
       :keywords '("MEH" "OK")
       :symbol ?·
       :face (defface eh/org-keyword-meh '((t :inherit org-done))
               "Face used for the OK keyword in Org"))
      (eh/org-register-keyword
       :keywords '("YES")
       :symbol ?·
       :face (defface eh/org-keyword-yes '((t :inherit eh/org-keyword-done))
               "Face used for the YES keyword in Org"))
      (eh/org-register-keyword
       :keywords '("NO")
       :symbol ?·
       :face (defface eh/org-keyword-no '((t :inherit eh/org-keyword-kill))
               "Face used for the NO keyword in Org"))
      (eh/org-register-keyword
       :keywords '("BURY" "WAIT" "HOLD" "LATER")
       :symbol ?~
       :face (defface eh/org-keyword-bury '((t :inherit org-done))
               "Face used for the WAIT keyword in Org"))
      (eh/org-register-keyword
       :keywords '("NEXT" "FLAG")
       :symbol ?◦
       :face (defface eh/org-keyword-next '((t :inherit org-todo))
               "Face used for the FLAG keyword in Org"))
      (eh/org-register-keyword
       :keywords '("TODO")
       :symbol ?◦
       :face (defface eh/org-keyword-todo '((t :inherit org-todo))
               "Face used for the TODO keyword in Org"))
      (eh/org-register-keyword
       :keywords '("HALT" "BLOK" "BLOCK")
       :symbol ?◊
       :face (defface eh/org-keyword-block '((t :inherit org-todo))
               "Face used for the BLOK keyword in Org"))
      (eh/org-register-keyword
       :keywords '("QUEST" "QSTN" "QUESTION")
       :symbol ??
       :face (defface eh/org-keyword-question '((t :inherit org-todo))
               "Face used for the QSTN keyword in Org"))
      (eh/org-register-keyword
       :keywords '("IDEA")
       :symbol ?ҩ
       :face (defface eh/org-keyword-idea '((t :inherit org-todo))
               "Face used for the IDEA keyword in Org"))
      (eh/org-register-keyword
       :keywords '("YAKS" "YAK")
       :symbol ?∞
       :face (defface eh/org-keyword-yaks '((t :inherit org-todo))
               "Face used for the YAK keyword in Org"))
      )
#+end_src

Set up some basic org styling that we'll run whenever we change themes:
#+begin_src elisp
(defun eh/org-update-theme ()
  ;; default styling for task keywords
  (set-face-attribute 'org-todo nil
                      :inherit 'fixed-pitch
		                  :box nil
		                  :height 1.0
                      :weight (face-attribute 'bold :weight))
  (set-face-attribute 'org-done nil
                      :inherit 'fixed-pitch
           	          :slant 'italic
                      :weight (face-attribute 'default :weight))

  ;; styling for headlines with keywords
  (set-face-attribute 'org-headline-todo nil
                      :foreground (face-attribute 'default :foreground)
                      :weight 'normal
                      :inherit 'default)
  (set-face-attribute 'org-headline-done nil
                      :inherit '(font-lock-comment-face default))

  ;; set things up for mixed/variable pitch
  (set-face-attribute 'org-hide nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)

  ;; Now set up theme-specific things?
  (when (eq (car custom-enabled-themes) 'doom-isohedron)
    (message "Setting up org faces for Isohedron")
    (set-face-attribute 'org-todo nil
                        :foreground (doom-color 'bg)
                        :background (doom-color 'fw-base3))
    (set-face-attribute 'eh/org-keyword-todo nil
                        :background (doom-color 'fw-green))
    (set-face-attribute 'eh/org-keyword-block nil
                        :background (doom-color 'fw-orange))
    (set-face-attribute 'eh/org-keyword-question nil
                        :background (doom-color 'fw-blue))
    (set-face-attribute 'eh/org-keyword-idea nil
                        :background (doom-color 'fw-teal))
    (set-face-attribute 'eh/org-keyword-yaks nil
                        :background (doom-color 'fw-purple))
    (set-face-attribute 'eh/org-keyword-next nil
                        :foreground (doom-color 'fw-yellow-text)
                        :background (doom-color 'fw-yellow))
    (set-face-attribute 'eh/org-keyword-bury nil
                        :foreground (doom-color 'fg-alt)
                        :background (doom-color 'fw-base5))
    (set-face-attribute 'eh/org-keyword-answer nil
                        :foreground (doom-color 'fw-blue))
    (set-face-attribute 'eh/org-keyword-yes nil
                        :foreground (doom-color 'fw-green))
    (set-face-attribute 'eh/org-keyword-no nil
                        :foreground (doom-color 'fw-red))
    (set-face-attribute 'eh/org-keyword-meh nil
                        :foreground (doom-color 'fg-alt))
    (set-face-attribute 'eh/org-keyword-done nil
                        :foreground (doom-color 'fg-alt))
    (set-face-attribute 'eh/org-keyword-kill nil
                        :foreground (doom-color 'fg-alt))
    )
  )

  ;; (eh/org-update-theme)
#+end_src
** Basic configuration
#+begin_src elisp
  (use-package org
    :config
    (eh/define-org-keywords)
    (eh/org-update-theme)
    ;; :init
    (setq org-directory "~/Org/"
          org-agenda-files '("~/Org/")
          org-refile-targets '((org-agenda-files . (:maxlevel . 5)))
          org-log-done t
          org-log-into-drawer t
          org-insert-heading-respect-content t
          org-cycle-separator-lines 1 ;; 2 blank lines to keep when collapsed
          org-indent-mode-turns-on-hiding-stars nil
          org-hide-leading-stars nil
          org-ellipsis "⏎"
          org-fontify-whole-block-delimiter-line nil
          org-fontify-whole-heading-line nil
          org-fontify-todo-headline t
          org-fontify-done-headline t
          org-src-preserve-indentation t
          org-startup-truncated t)
    (setq org-todo-keywords
          '((sequence "BURY(b)" "NEXT(n)" "TODO(t)" "HALT(h)" "|" "DONE(d!)" "KILL(k@)")
            (sequence "QUEST(q)" "|" "MEH(m)" "YES(Y)" "NO(N)" "ANSWER(a@)")
            (type "IDEA(i)" "YAKS(y)" "GOAL(g)" "|")
            ))
    :hook
    (org-mode . (lambda()
                  (org-indent-mode t)
                  (visual-line-mode t)
                  ;; (variable-pitch-mode t)
                  (mixed-pitch-mode t)
                  ))
    (after-enable-theme . eh/org-update-theme)
    )
  ;; (eh/org-update-theme)
#+end_src
** Making org prettier
#+begin_src elisp
(use-package org-superstar 
  :init
  (setq org-superstar-cycle-headline-bullets nil
        org-superstar-special-todo-items t
        org-superstar-leading-fallback "·"
        org-superstar-leading-bullet "·"
        org-superstar-remove-leading-stars nil
        org-superstar-headline-bullets-list '("◆" "•")
        org-superstar-prettify-item-bullets nil
        )
  (defun eh/org-superstar-update-theme ()
    (set-face-attribute 'org-superstar-header-bullet nil :weight (face-attribute 'default :weight) :font (face-attribute 'fixed-pitch :font))
    (set-face-attribute 'org-superstar-leading nil :foreground (face-attribute 'org-hide :foreground))
    )
  :config
  (eh/org-superstar-update-theme)
  :hook 
  (org-mode . org-superstar-mode)
  (after-enable-theme . eh/org-superstar-update-theme)
  )
#+end_src
** Making org more powerful
*** For capturing infomation
Being able to capture ideas from anywhere, especially with the ability to send them to multiple places and link them to where they came from, is amazing.

*** For retrieving information
The agenda is a big part of the power of org.
#+begin_src elisp
(use-package org-super-agenda)
#+end_src

Here's some fiddling trying to get a nice agenda going:
#+begin_src elisp :tangle no
(let ((org-super-agenda-groups
       '(
         (:discard (:tag "meta"))
         (:name "Today" ; the name of the section
                ;; :time-grid t ; items that go on the time grid
                :deadline (past today)
                :scheduled (past today)
                :priority "A") ; high priority items
         (:name "Follow Up"
                :todo ("BLOCK" "BLOK" "QSTN")) ; wait? hold?
         )))
  (org-agenda nil "t"))
#+end_src


* Language support
** Misc small packages
#+begin_src elisp
(use-package fish-mode)
(use-package haml-mode)
(use-package slim-mode)
#+end_src
** Writing in Markdown
As much as I love org, sometimes I do still have to deal with Markdown. And it's usually github-flavored, so we'll need a package for that.
#+begin_src elisp
(use-package markdown-mode
  :mode
  (("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . gfm-mode))
  :hook
  (gfm-mode . mixed-pitch-mode)
  (markdown-mode . mixed-pitch-mode))
#+end_src
** Javascript with Vue
I think vue-mode gets us most of what we need. It handles markup and JS in the same file, which is the main thing.
#+begin_src elisp
(use-package vue-mode)
#+end_src
We may also need web-mode but it's such a huge general-purpose ball of mud that I'm hesitant to add it unless it's definitely needed.
* Things that don't work right [3/10]
:PROPERTIES:
:visibility: folded
:END:
** TODO Something is getting the toto keyword colors stuck in weird states
The automatic theme change might be where things are going wrong. Or maybe it's modus. It seems like ... wait ... I did a few switches in a row and now the keyword colors are gone entirely.
- Loaded isohedron with =M-x load-theme= and everything looks good
I suspect I need to do something smarter with my various ~set-face-attribute~ calls. They get overridden by themes, but they don't ever get explicitly unset, so they tend to interact strangely. 
** TODO tab after fold indicator
** TODO persistent scratch can get lost in some situations
It needs backup. I saw some sort of dismissive comment about how you just need to have it, but it's not actually clear /how/ to have it. Was is a different package?
** DONE Redo bind for =C-h F= 
CLOSED: [2022-04-16 Sat 22:24]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-16 Sat 22:24]
:END:
** TODO footnote inside table messes up alignment (mixed pitch hierarchy issue)
Footnote face inherits from button (in modus)
This same issue exists in Isohedron and 
** TODO The goal with typography and theme
I don't need everything to work with anything. But I do want to have a few sets of config (a few themes, a few fonts) that can all work together with minimal pain. As much as it seems ... dirty ... I wonder if customize might not be the best way to accomplish that. But some hand-rolled functions could probably solve the problem as well.
- Register change hooks for themes _or_ font stacks
- The idea of a font stack as a more first-class thing
** DONE =M-Ret= with list items vs headlines
CLOSED: [2022-04-16 Sat 22:34]
:LOGBOOK:
- State "DONE"       from "YAKS"       [2022-04-16 Sat 22:34]
:END:
On headlines, it works inside the line, on items it ... didn't.
- this is a list item
** DONE Capture templates
CLOSED: [2022-04-16 Sat 22:35]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-16 Sat 22:35]
:END:
** YAKS When I'm on my laptop, the minibuffer is way too invisible. It's fine in windows (which is what I use for actual work) but when it's full-screen, it's a problem (which is how any personal hacking is done)
** TODO Out with centaur-tabs, in with bufler
*** DONE Get rid of centaur-tabs
CLOSED: [2022-04-16 Sat 11:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-16 Sat 11:47]
:END:
*** TODO Set up some keybindings for bufler
* Footnotes

[fn:1] ~org-babel-demarcate-block~
Make sure there's some content (not just whitespace) between the point and the last source block, or weird things happen. In that case, you can also select a region before the command to wrap it in a source block, which seem consistently reliable. The upside of the weirdness is that this same command, inside of a source block, will split it into two separate ones at point.
